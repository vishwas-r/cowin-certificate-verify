{"ast":null,"code":"/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar env = require('../env');\n\nvar forge = require('node-forge');\n\nvar LinkedDataSignature = require('./LinkedDataSignature');\n\nmodule.exports = /*#__PURE__*/function (_LinkedDataSignature) {\n  _inherits(LinkedDataSignature2015, _LinkedDataSignature);\n\n  var _super = _createSuper(LinkedDataSignature2015);\n\n  /**\n   * Advanced optional parameters and overrides:\n   *\n   * @param [domain] {string} domain to include in the signature.\n   * @param [nonce] {string} nonce to include in the signature.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  function LinkedDataSignature2015() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$type = _ref.type,\n        type = _ref$type === void 0 ? 'LinkedDataSignature2015' : _ref$type,\n        privateKeyPem = _ref.privateKeyPem,\n        publicKeyPem = _ref.publicKeyPem,\n        creator = _ref.creator,\n        date = _ref.date,\n        domain = _ref.domain,\n        nonce = _ref.nonce,\n        useNativeCanonize = _ref.useNativeCanonize;\n\n    _classCallCheck(this, LinkedDataSignature2015);\n\n    if (domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n\n    if (nonce !== undefined && typeof nonce !== 'string') {\n      throw new TypeError('\"nonce\" must be a string.');\n    }\n\n    _this = _super.call(this, {\n      type: type,\n      creator: creator,\n      date: date,\n      domain: domain,\n      nonce: nonce,\n      useNativeCanonize: useNativeCanonize\n    });\n    _this.legacy = true;\n    _this.privateKeyPem = privateKeyPem;\n    _this.publicKeyPem = publicKeyPem;\n    _this.nonce = nonce;\n    _this.domain = domain;\n    return _this;\n  }\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n\n\n  _createClass(LinkedDataSignature2015, [{\n    key: \"updateProof\",\n    value: function () {\n      var _updateProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n        var proof;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                proof = _ref2.proof;\n\n                if (this.domain !== undefined) {\n                  proof.domain = this.domain;\n                }\n\n                if (this.nonce !== undefined) {\n                  proof.nonce = this.nonce;\n                }\n\n                return _context.abrupt(\"return\", proof);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function updateProof(_x) {\n        return _updateProof.apply(this, arguments);\n      }\n\n      return updateProof;\n    }()\n    /**\n     * @param proof {object} the proof to be verified.\n     * @param document {object} the document the proof applies to.\n     * @param purpose {ProofPurpose}\n     * @param documentLoader {function}\n     * @param expansionMap {function}\n     * @param compactProof {boolean}\n     *\n     * @returns {Promise<{object}>} Resolves with the verification result.\n     */\n\n  }, {\n    key: \"verifyProof\",\n    value: function () {\n      var _verifyProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n        var proof, document, purpose, documentLoader, expansionMap, compactProof;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                proof = _ref3.proof, document = _ref3.document, purpose = _ref3.purpose, documentLoader = _ref3.documentLoader, expansionMap = _ref3.expansionMap, compactProof = _ref3.compactProof;\n                _context2.prev = 1;\n\n                if (!(this.domain !== undefined && proof.domain !== this.domain)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                throw new Error('The domain is not as expected; ' + \"domain=\\\"\".concat(proof.domain, \"\\\", expected=\\\"\").concat(this.domain, \"\\\"\"));\n\n              case 4:\n                return _context2.abrupt(\"return\", _get(_getPrototypeOf(LinkedDataSignature2015.prototype), \"verifyProof\", this).call(this, {\n                  proof: proof,\n                  document: document,\n                  purpose: purpose,\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap,\n                  compactProof: compactProof\n                }));\n\n              case 7:\n                _context2.prev = 7;\n                _context2.t0 = _context2[\"catch\"](1);\n                return _context2.abrupt(\"return\", {\n                  verified: false,\n                  error: _context2.t0\n                });\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 7]]);\n      }));\n\n      function verifyProof(_x2) {\n        return _verifyProof.apply(this, arguments);\n      }\n\n      return verifyProof;\n    }()\n    /**\n     * @param document {object} to be signed/verified.\n     * @param proof {object}\n     * @param documentLoader {function}\n     * @param expansionMap {function}\n     * @param compactProof {boolean}\n     *\n     * @returns {Promise<{Uint8Array}>}.\n     */\n\n  }, {\n    key: \"createVerifyData\",\n    value: function () {\n      var _createVerifyData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4) {\n        var document, proof, documentLoader, expansionMap, c14n, verifyData, headers, keys, i, key, value, buffer;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                document = _ref4.document, proof = _ref4.proof, documentLoader = _ref4.documentLoader, expansionMap = _ref4.expansionMap;\n                _context3.next = 3;\n                return this.canonize(document, {\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap\n                });\n\n              case 3:\n                c14n = _context3.sent;\n                verifyData = '';\n                headers = {\n                  'http://purl.org/dc/elements/1.1/created': proof.created,\n                  'https://w3id.org/security#domain': proof.domain,\n                  'https://w3id.org/security#nonce': proof.nonce\n                }; // add headers in lexicographical order\n\n                keys = Object.keys(headers).sort();\n\n                for (i = 0; i < keys.length; ++i) {\n                  key = keys[i];\n                  value = headers[key];\n\n                  if (!(value === null || value === undefined)) {\n                    verifyData += key + ': ' + value + '\\n';\n                  }\n                }\n\n                verifyData += c14n;\n                buffer = new forge.util.ByteBuffer(verifyData, 'utf8');\n                return _context3.abrupt(\"return\", forge.util.binary.raw.decode(buffer.getBytes()));\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function createVerifyData(_x3) {\n        return _createVerifyData.apply(this, arguments);\n      }\n\n      return createVerifyData;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n        var verifyData, proof, privateKeyPem, signature, crypto, signer, privateKey, md;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                verifyData = _ref5.verifyData, proof = _ref5.proof;\n                privateKeyPem = this.privateKeyPem;\n\n                if (!(typeof privateKeyPem !== 'string')) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                throw new TypeError('\"privateKeyPem\" must be a PEM formatted string.');\n\n              case 4:\n                if (env.nodejs) {\n                  // optimize using node libraries\n                  crypto = require('crypto');\n                  signer = crypto.createSign('RSA-SHA256');\n                  signer.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));\n                  signature = signer.sign(privateKeyPem, 'base64');\n                } else {\n                  // browser or other environment\n                  privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n                  md = forge.md.sha256.create();\n                  md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n                  signature = forge.util.encode64(privateKey.sign(md));\n                }\n\n                proof.signatureValue = signature;\n                return _context4.abrupt(\"return\", proof);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function sign(_x4) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"verifySignature\",\n    value: function () {\n      var _verifySignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref6) {\n        var verifyData, proof, publicKeyPem, crypto, verifier, publicKey, md;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                verifyData = _ref6.verifyData, proof = _ref6.proof;\n                publicKeyPem = this.publicKeyPem;\n\n                if (!(typeof publicKeyPem !== 'string')) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                throw new TypeError('Could not verify signature; invalid \"publicKeyPem\".');\n\n              case 4:\n                if (!env.nodejs) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                // optimize using node libraries\n                crypto = require('crypto');\n                verifier = crypto.createVerify('RSA-SHA256');\n                verifier.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));\n                return _context5.abrupt(\"return\", verifier.verify(publicKeyPem, proof.signatureValue, 'base64'));\n\n              case 9:\n                // browser or other environment\n                publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n                md = forge.md.sha256.create();\n                md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n                _context5.prev = 12;\n                return _context5.abrupt(\"return\", publicKey.verify(md.digest().bytes(), forge.util.decode64(proof.signatureValue)));\n\n              case 16:\n                _context5.prev = 16;\n                _context5.t0 = _context5[\"catch\"](12);\n                return _context5.abrupt(\"return\", false);\n\n              case 19:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[12, 16]]);\n      }));\n\n      function verifySignature(_x5) {\n        return _verifySignature.apply(this, arguments);\n      }\n\n      return verifySignature;\n    }()\n  }, {\n    key: \"getVerificationMethod\",\n    value: function () {\n      var _getVerificationMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref7) {\n        var proof, documentLoader, verificationMethod;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                proof = _ref7.proof, documentLoader = _ref7.documentLoader;\n                _context6.next = 3;\n                return _get(_getPrototypeOf(LinkedDataSignature2015.prototype), \"getVerificationMethod\", this).call(this, {\n                  proof: proof,\n                  documentLoader: documentLoader\n                });\n\n              case 3:\n                verificationMethod = _context6.sent;\n\n                if (!this.publicKeyPem) {\n                  this.publicKeyPem = verificationMethod.publicKeyPem;\n                }\n\n                return _context6.abrupt(\"return\", verificationMethod);\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getVerificationMethod(_x6) {\n        return _getVerificationMethod.apply(this, arguments);\n      }\n\n      return getVerificationMethod;\n    }()\n  }]);\n\n  return LinkedDataSignature2015;\n}(LinkedDataSignature);","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature2015.js"],"names":["env","require","forge","LinkedDataSignature","module","exports","type","privateKeyPem","publicKeyPem","creator","date","domain","nonce","useNativeCanonize","undefined","TypeError","legacy","proof","document","purpose","documentLoader","expansionMap","compactProof","Error","verified","error","canonize","c14n","verifyData","headers","created","keys","Object","sort","i","length","key","value","buffer","util","ByteBuffer","binary","raw","decode","getBytes","nodejs","crypto","signer","createSign","update","Buffer","from","byteOffset","signature","sign","privateKey","pki","privateKeyFromPem","md","sha256","create","encode","encode64","signatureValue","verifier","createVerify","verify","publicKey","publicKeyFromPem","digest","bytes","decode64","verificationMethod"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('../env');\nconst forge = require('node-forge');\nconst LinkedDataSignature = require('./LinkedDataSignature');\n\nmodule.exports = class LinkedDataSignature2015 extends LinkedDataSignature {\n  /**\n   * Advanced optional parameters and overrides:\n   *\n   * @param [domain] {string} domain to include in the signature.\n   * @param [nonce] {string} nonce to include in the signature.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor({\n    type = 'LinkedDataSignature2015',\n    privateKeyPem, publicKeyPem, creator, date, domain, nonce,\n    useNativeCanonize} = {}) {\n    if(domain !== undefined && typeof domain !== 'string') {\n      throw new TypeError('\"domain\" must be a string.');\n    }\n    if(nonce !== undefined && typeof nonce !== 'string') {\n      throw new TypeError('\"nonce\" must be a string.');\n    }\n    super({type, creator, date, domain, nonce, useNativeCanonize});\n    this.legacy = true;\n    this.privateKeyPem = privateKeyPem;\n    this.publicKeyPem = publicKeyPem;\n    this.nonce = nonce;\n    this.domain = domain;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async updateProof({proof}) {\n    if(this.domain !== undefined) {\n      proof.domain = this.domain;\n    }\n    if(this.nonce !== undefined) {\n      proof.nonce = this.nonce;\n    }\n    return proof;\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({\n    proof, document, purpose, documentLoader, expansionMap,\n    compactProof}) {\n    try {\n      // check domain\n      if(this.domain !== undefined && proof.domain !== this.domain) {\n        throw new Error('The domain is not as expected; ' +\n          `domain=\"${proof.domain}\", expected=\"${this.domain}\"`);\n      }\n\n      return super.verifyProof({\n        proof, document, purpose, documentLoader, expansionMap,\n        compactProof});\n    } catch(error) {\n      return {verified: false, error};\n    }\n  }\n\n  /**\n   * @param document {object} to be signed/verified.\n   * @param proof {object}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<{Uint8Array}>}.\n   */\n  async createVerifyData({\n    document, proof, documentLoader, expansionMap}) {\n    const c14n = await this.canonize(document, {\n      documentLoader,\n      expansionMap\n    });\n\n    let verifyData = '';\n    const headers = {\n      'http://purl.org/dc/elements/1.1/created': proof.created,\n      'https://w3id.org/security#domain': proof.domain,\n      'https://w3id.org/security#nonce': proof.nonce\n    };\n    // add headers in lexicographical order\n    const keys = Object.keys(headers).sort();\n    for(let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const value = headers[key];\n      if(!(value === null || value === undefined)) {\n        verifyData += key + ': ' + value + '\\n';\n      }\n    }\n    verifyData += c14n;\n    const buffer = new forge.util.ByteBuffer(verifyData, 'utf8');\n    return forge.util.binary.raw.decode(buffer.getBytes());\n  }\n\n  async sign({verifyData, proof}) {\n    const {privateKeyPem} = this;\n    if(typeof privateKeyPem !== 'string') {\n      throw new TypeError('\"privateKeyPem\" must be a PEM formatted string.');\n    }\n\n    let signature;\n    if(env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n      const signer = crypto.createSign('RSA-SHA256');\n      signer.update(Buffer.from(\n        verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      signature = signer.sign(privateKeyPem, 'base64');\n    } else {\n      // browser or other environment\n      const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);\n      const md = forge.md.sha256.create();\n      md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n      signature = forge.util.encode64(privateKey.sign(md));\n    }\n\n    proof.signatureValue = signature;\n    return proof;\n  }\n\n  async verifySignature({verifyData, proof}) {\n    const {publicKeyPem} = this;\n    if(typeof publicKeyPem !== 'string') {\n      throw new TypeError(\n        'Could not verify signature; invalid \"publicKeyPem\".');\n    }\n\n    if(env.nodejs) {\n      // optimize using node libraries\n      const crypto = require('crypto');\n      const verifier = crypto.createVerify('RSA-SHA256');\n      verifier.update(Buffer.from(\n        verifyData.buffer, verifyData.byteOffset, verifyData.length));\n      return verifier.verify(publicKeyPem, proof.signatureValue, 'base64');\n    }\n\n    // browser or other environment\n    const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);\n    const md = forge.md.sha256.create();\n    md.update(forge.util.binary.raw.encode(verifyData), 'binary');\n    try {\n      return publicKey.verify(\n        md.digest().bytes(), forge.util.decode64(proof.signatureValue));\n    } catch(e) {\n      // simply return false, do return information about malformed signature\n      return false;\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    const verificationMethod = await super.getVerificationMethod(\n      {proof, documentLoader});\n    if(!this.publicKeyPem) {\n      this.publicKeyPem = verificationMethod.publicKeyPem;\n    }\n    return verificationMethod;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}