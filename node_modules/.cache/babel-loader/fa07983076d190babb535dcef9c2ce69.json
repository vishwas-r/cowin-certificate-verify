{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _slicedToArray = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar constants = require('../constants');\n\nvar jsonld = require('jsonld');\n\nvar ProofPurpose = require('./ProofPurpose');\n\nmodule.exports = /*#__PURE__*/function (_ProofPurpose) {\n  _inherits(ControllerProofPurpose, _ProofPurpose);\n\n  var _super = _createSuper(ControllerProofPurpose);\n\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  function ControllerProofPurpose() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        term = _ref.term,\n        controller = _ref.controller,\n        date = _ref.date,\n        _ref$maxTimestampDelt = _ref.maxTimestampDelta,\n        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;\n\n    _classCallCheck(this, ControllerProofPurpose);\n\n    _this = _super.call(this, {\n      term: term,\n      date: date,\n      maxTimestampDelta: maxTimestampDelta\n    });\n\n    if (controller !== undefined) {\n      if (typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n\n      _this.controller = controller;\n    }\n\n    return _this;\n  }\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n\n\n  _createClass(ControllerProofPurpose, [{\n    key: \"validate\",\n    value: function () {\n      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(proof, _ref2) {\n        var verificationMethod, documentLoader, expansionMap, result, verificationId, controller, owner, controllerId, _yield$jsonld$frame, _yield$jsonld$frame$, _yield$jsonld$frame$$, framed, verificationMethods;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                verificationMethod = _ref2.verificationMethod, documentLoader = _ref2.documentLoader, expansionMap = _ref2.expansionMap;\n                _context.prev = 1;\n                _context.next = 4;\n                return _get(_getPrototypeOf(ControllerProofPurpose.prototype), \"validate\", this).call(this, proof, {\n                  verificationMethod: verificationMethod,\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap\n                });\n\n              case 4:\n                result = _context.sent;\n\n                if (result.valid) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw result.error;\n\n              case 7:\n                verificationId = verificationMethod.id; // if no `controller` specified, use verification method's\n\n                if (!this.controller) {\n                  _context.next = 12;\n                  break;\n                }\n\n                result.controller = this.controller;\n                _context.next = 42;\n                break;\n\n              case 12:\n                // support legacy `owner` property\n                controller = verificationMethod.controller, owner = verificationMethod.owner;\n\n                if (!controller) {\n                  _context.next = 25;\n                  break;\n                }\n\n                if (!(typeof controller === 'object')) {\n                  _context.next = 18;\n                  break;\n                }\n\n                controllerId = controller.id;\n                _context.next = 23;\n                break;\n\n              case 18:\n                if (!(typeof controller !== 'string')) {\n                  _context.next = 22;\n                  break;\n                }\n\n                throw new TypeError('\"controller\" must be a string representing a URL.');\n\n              case 22:\n                controllerId = controller;\n\n              case 23:\n                _context.next = 35;\n                break;\n\n              case 25:\n                if (!owner) {\n                  _context.next = 35;\n                  break;\n                }\n\n                if (!(typeof owner === 'object')) {\n                  _context.next = 30;\n                  break;\n                }\n\n                controllerId = owner.id;\n                _context.next = 35;\n                break;\n\n              case 30:\n                if (!(typeof owner !== 'string')) {\n                  _context.next = 34;\n                  break;\n                }\n\n                throw new TypeError('\"owner\" must be a string representing a URL.');\n\n              case 34:\n                controllerId = owner;\n\n              case 35:\n                _context.next = 37;\n                return jsonld.frame(controllerId, _defineProperty({\n                  '@context': constants.SECURITY_CONTEXT_URL,\n                  id: controllerId\n                }, this.term, {\n                  '@embed': '@never',\n                  id: verificationId\n                }), {\n                  documentLoader: documentLoader,\n                  compactToRelative: false\n                });\n\n              case 37:\n                _yield$jsonld$frame = _context.sent;\n                _yield$jsonld$frame$ = _slicedToArray(_yield$jsonld$frame['@graph'], 1);\n                _yield$jsonld$frame$$ = _yield$jsonld$frame$[0];\n                framed = _yield$jsonld$frame$$ === void 0 ? {} : _yield$jsonld$frame$$;\n                result.controller = framed;\n\n              case 42:\n                verificationMethods = jsonld.getValues(result.controller, this.term);\n                result.valid = verificationMethods.some(function (vm) {\n                  return vm === verificationId || typeof vm === 'object' && vm.id === verificationId;\n                });\n\n                if (result.valid) {\n                  _context.next = 46;\n                  break;\n                }\n\n                throw new Error(\"Verification method \\\"\".concat(verificationMethod.id, \"\\\" not authorized \") + \"by controller for proof purpose \\\"\".concat(this.term, \"\\\".\"));\n\n              case 46:\n                return _context.abrupt(\"return\", result);\n\n              case 49:\n                _context.prev = 49;\n                _context.t0 = _context[\"catch\"](1);\n                return _context.abrupt(\"return\", {\n                  valid: false,\n                  error: _context.t0\n                });\n\n              case 52:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 49]]);\n      }));\n\n      function validate(_x, _x2) {\n        return _validate.apply(this, arguments);\n      }\n\n      return validate;\n    }()\n  }]);\n\n  return ControllerProofPurpose;\n}(ProofPurpose);","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js"],"names":["constants","require","jsonld","ProofPurpose","module","exports","term","controller","date","maxTimestampDelta","Infinity","undefined","TypeError","proof","verificationMethod","documentLoader","expansionMap","result","valid","error","verificationId","id","owner","controllerId","frame","SECURITY_CONTEXT_URL","compactToRelative","framed","verificationMethods","getValues","some","vm","Error"],"mappings":"AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMA,SAAS,GAAGC,OAAO,CAAC,cAAD,CAAzB;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAME,YAAY,GAAGF,OAAO,CAAC,gBAAD,CAA5B;;AAEAG,MAAM,CAACC,OAAP;AAAA;;AAAA;;AACE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,oCAAyE;AAAA;;AAAA,mFAAJ,EAAI;AAAA,QAA5DC,IAA4D,QAA5DA,IAA4D;AAAA,QAAtDC,UAAsD,QAAtDA,UAAsD;AAAA,QAA1CC,IAA0C,QAA1CA,IAA0C;AAAA,qCAApCC,iBAAoC;AAAA,QAApCA,iBAAoC,sCAAhBC,QAAgB;;AAAA;;AACvE,8BAAM;AAACJ,MAAAA,IAAI,EAAJA,IAAD;AAAOE,MAAAA,IAAI,EAAJA,IAAP;AAAaC,MAAAA,iBAAiB,EAAjBA;AAAb,KAAN;;AACA,QAAGF,UAAU,KAAKI,SAAlB,EAA6B;AAC3B,UAAG,OAAOJ,UAAP,KAAsB,QAAzB,EAAmC;AACjC,cAAM,IAAIK,SAAJ,CAAc,iCAAd,CAAN;AACD;;AACD,YAAKL,UAAL,GAAkBA,UAAlB;AACD;;AAPsE;AAQxE;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAxCA;AAAA;AAAA;AAAA,+EAyCE,iBAAeM,KAAf;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAuBC,gBAAAA,kBAAvB,SAAuBA,kBAAvB,EAA2CC,cAA3C,SAA2CA,cAA3C,EAA2DC,YAA3D,SAA2DA,YAA3D;AAAA;AAAA;AAAA,4GAGMH,KAHN,EAGa;AAACC,kBAAAA,kBAAkB,EAAlBA,kBAAD;AAAqBC,kBAAAA,cAAc,EAAdA,cAArB;AAAqCC,kBAAAA,YAAY,EAAZA;AAArC,iBAHb;;AAAA;AAEUC,gBAAAA,MAFV;;AAAA,oBAIQA,MAAM,CAACC,KAJf;AAAA;AAAA;AAAA;;AAAA,sBAKYD,MAAM,CAACE,KALnB;;AAAA;AAQeC,gBAAAA,cARf,GAQiCN,kBARjC,CAQWO,EARX,EAUI;;AAVJ,qBAWO,KAAKd,UAXZ;AAAA;AAAA;AAAA;;AAYMU,gBAAAA,MAAM,CAACV,UAAP,GAAoB,KAAKA,UAAzB;AAZN;AAAA;;AAAA;AAcM;AACOA,gBAAAA,UAfb,GAekCO,kBAflC,CAeaP,UAfb,EAeyBe,KAfzB,GAekCR,kBAflC,CAeyBQ,KAfzB;;AAAA,qBAiBSf,UAjBT;AAAA;AAAA;AAAA;;AAAA,sBAkBW,OAAOA,UAAP,KAAsB,QAlBjC;AAAA;AAAA;AAAA;;AAmBUgB,gBAAAA,YAAY,GAAGhB,UAAU,CAACc,EAA1B;AAnBV;AAAA;;AAAA;AAAA,sBAoBkB,OAAOd,UAAP,KAAsB,QApBxC;AAAA;AAAA;AAAA;;AAAA,sBAqBgB,IAAIK,SAAJ,CACJ,mDADI,CArBhB;;AAAA;AAwBUW,gBAAAA,YAAY,GAAGhB,UAAf;;AAxBV;AAAA;AAAA;;AAAA;AAAA,qBA0BgBe,KA1BhB;AAAA;AAAA;AAAA;;AAAA,sBA2BW,OAAOA,KAAP,KAAiB,QA3B5B;AAAA;AAAA;AAAA;;AA4BUC,gBAAAA,YAAY,GAAGD,KAAK,CAACD,EAArB;AA5BV;AAAA;;AAAA;AAAA,sBA6BkB,OAAOC,KAAP,KAAiB,QA7BnC;AAAA;AAAA;AAAA;;AAAA,sBA8BgB,IAAIV,SAAJ,CACJ,8CADI,CA9BhB;;AAAA;AAiCUW,gBAAAA,YAAY,GAAGD,KAAf;;AAjCV;AAAA;AAAA,uBAsC8CpB,MAAM,CAACsB,KAAP,CAAaD,YAAb;AACtC,8BAAYvB,SAAS,CAACyB,oBADgB;AAEtCJ,kBAAAA,EAAE,EAAEE;AAFkC,mBAKrC,KAAKjB,IALgC,EAKzB;AACX,4BAAU,QADC;AAEXe,kBAAAA,EAAE,EAAED;AAFO,iBALyB,GASrC;AAACL,kBAAAA,cAAc,EAAdA,cAAD;AAAiBW,kBAAAA,iBAAiB,EAAE;AAApC,iBATqC,CAtC9C;;AAAA;AAAA;AAAA,0EAsCa,QAtCb;AAAA;AAsCwBC,gBAAAA,MAtCxB,sCAsCiC,EAtCjC;AAgDMV,gBAAAA,MAAM,CAACV,UAAP,GAAoBoB,MAApB;;AAhDN;AAkDUC,gBAAAA,mBAlDV,GAkDgC1B,MAAM,CAAC2B,SAAP,CAC1BZ,MAAM,CAACV,UADmB,EACP,KAAKD,IADE,CAlDhC;AAoDIW,gBAAAA,MAAM,CAACC,KAAP,GAAeU,mBAAmB,CAACE,IAApB,CAAyB,UAAAC,EAAE;AAAA,yBACxCA,EAAE,KAAKX,cAAP,IACC,OAAOW,EAAP,KAAc,QAAd,IAA0BA,EAAE,CAACV,EAAH,KAAUD,cAFG;AAAA,iBAA3B,CAAf;;AApDJ,oBAuDQH,MAAM,CAACC,KAvDf;AAAA;AAAA;AAAA;;AAAA,sBAwDY,IAAIc,KAAJ,CACJ,gCAAwBlB,kBAAkB,CAACO,EAA3C,sEACoC,KAAKf,IADzC,QADI,CAxDZ;;AAAA;AAAA,iDA4DWW,MA5DX;;AAAA;AAAA;AAAA;AAAA,iDA8DW;AAACC,kBAAAA,KAAK,EAAE,KAAR;AAAeC,kBAAAA,KAAK;AAApB,iBA9DX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAzCF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,EAAsDhB,YAAtD","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('../constants');\nconst jsonld = require('jsonld');\nconst ProofPurpose = require('./ProofPurpose');\n\nmodule.exports = class ControllerProofPurpose extends ProofPurpose {\n  /**\n   * Creates a proof purpose that will validate whether or not the verification\n   * method in a proof was authorized by its declared controller for the\n   * proof's purpose.\n   *\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [controller] {object} the description of the controller, if it\n   *   is not to be dereferenced via a `documentLoader`.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, controller, date, maxTimestampDelta = Infinity} = {}) {\n    super({term, date, maxTimestampDelta});\n    if(controller !== undefined) {\n      if(typeof controller !== 'object') {\n        throw new TypeError('\"controller\" must be an object.');\n      }\n      this.controller = controller;\n    }\n  }\n\n  /**\n   * Validates the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof\n   * @param verificationMethod\n   * @param documentLoader\n   * @param expansionMap\n   *\n   * @throws {Error} If verification method not authorized by controller\n   * @throws {Error} If proof's created timestamp is out of range\n   *\n   * @returns {Promise<{valid: boolean, error: Error}>}\n   */\n  async validate(proof, {verificationMethod, documentLoader, expansionMap}) {\n    try {\n      const result = await super.validate(\n        proof, {verificationMethod, documentLoader, expansionMap});\n      if(!result.valid) {\n        throw result.error;\n      }\n\n      const {id: verificationId} = verificationMethod;\n\n      // if no `controller` specified, use verification method's\n      if(this.controller) {\n        result.controller = this.controller;\n      } else {\n        // support legacy `owner` property\n        const {controller, owner} = verificationMethod;\n        let controllerId;\n        if(controller) {\n          if(typeof controller === 'object') {\n            controllerId = controller.id;\n          } else if(typeof controller !== 'string') {\n            throw new TypeError(\n              '\"controller\" must be a string representing a URL.');\n          } else {\n            controllerId = controller;\n          }\n        } else if(owner) {\n          if(typeof owner === 'object') {\n            controllerId = owner.id;\n          } else if(typeof owner !== 'string') {\n            throw new TypeError(\n              '\"owner\" must be a string representing a URL.');\n          } else {\n            controllerId = owner;\n          }\n        }\n        // Note: `expansionMap` is intentionally not passed; we can safely drop\n        // properties here and must allow for it\n        const {'@graph': [framed = {}]} = await jsonld.frame(controllerId, {\n          '@context': constants.SECURITY_CONTEXT_URL,\n          id: controllerId,\n          // the term should be in the json-ld object the controllerId resolves\n          // to.\n          [this.term]: {\n            '@embed': '@never',\n            id: verificationId\n          }\n        }, {documentLoader, compactToRelative: false});\n        result.controller = framed;\n      }\n      const verificationMethods = jsonld.getValues(\n        result.controller, this.term);\n      result.valid = verificationMethods.some(vm =>\n        vm === verificationId ||\n        (typeof vm === 'object' && vm.id === verificationId));\n      if(!result.valid) {\n        throw new Error(\n          `Verification method \"${verificationMethod.id}\" not authorized ` +\n          `by controller for proof purpose \"${this.term}\".`);\n      }\n      return result;\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}