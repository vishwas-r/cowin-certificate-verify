{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  function ProofPurpose() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        term = _ref.term,\n        date = _ref.date,\n        _ref$maxTimestampDelt = _ref.maxTimestampDelta,\n        maxTimestampDelta = _ref$maxTimestampDelt === void 0 ? Infinity : _ref$maxTimestampDelt;\n\n    _classCallCheck(this, ProofPurpose);\n\n    if (term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n\n    if (maxTimestampDelta !== undefined && typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n\n    this.term = term;\n\n    if (date !== undefined) {\n      this.date = new Date(date);\n\n      if (isNaN(this.date)) {\n        throw TypeError(\"\\\"date\\\" \\\"\".concat(date, \"\\\" is not a valid date.\"));\n      }\n    }\n\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n\n\n  _createClass(ProofPurpose, [{\n    key: \"validate\",\n    value: function () {\n      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(proof, _ref2) {\n        var document, suite, verificationMethod, documentLoader, expansionMap, expected, delta, created;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                document = _ref2.document, suite = _ref2.suite, verificationMethod = _ref2.verificationMethod, documentLoader = _ref2.documentLoader, expansionMap = _ref2.expansionMap;\n                _context.prev = 1;\n\n                if (!(this.maxTimestampDelta !== Infinity)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                expected = (this.date || new Date()).getTime();\n                delta = this.maxTimestampDelta * 1000;\n                created = new Date(proof.created).getTime(); // comparing this way handles NaN case where `created` is invalid\n\n                if (created >= expected - delta && created <= expected + delta) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new Error('The proof\\'s created timestamp is out of range.');\n\n              case 8:\n                return _context.abrupt(\"return\", {\n                  valid: true\n                });\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](1);\n                return _context.abrupt(\"return\", {\n                  valid: false,\n                  error: _context.t0\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 11]]);\n      }));\n\n      function validate(_x, _x2) {\n        return _validate.apply(this, arguments);\n      }\n\n      return validate;\n    }()\n    /**\n     * Called to update a proof when it is being created, adding any properties\n     * specific to this purpose. This method is called prior to the proof\n     * value being generated such that any properties added may be, for example,\n     * included in a digital signature value.\n     *\n     * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n     *   to update.\n     *\n     * @return {Promise<object>} resolves to the proof instance (in the\n     *   `constants.SECURITY_CONTEXT_URL`.\n     */\n\n  }, {\n    key: \"update\",\n    value: function () {\n      var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(proof, _ref3) {\n        var document, suite, documentLoader, expansionMap;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                document = _ref3.document, suite = _ref3.suite, documentLoader = _ref3.documentLoader, expansionMap = _ref3.expansionMap;\n                proof.proofPurpose = this.term;\n                return _context2.abrupt(\"return\", proof);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function update(_x3, _x4) {\n        return _update.apply(this, arguments);\n      }\n\n      return update;\n    }()\n    /**\n     * Determines if the given proof has a purpose that matches this instance,\n     * i.e. this ProofPurpose instance should be used to validate the given\n     * proof.\n     *\n     * @param proof {object} the proof to check.\n     *\n     * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n     */\n\n  }, {\n    key: \"match\",\n    value: function () {\n      var _match = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(proof, _ref4) {\n        var document, documentLoader, expansionMap;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                document = _ref4.document, documentLoader = _ref4.documentLoader, expansionMap = _ref4.expansionMap;\n                return _context3.abrupt(\"return\", proof.proofPurpose === this.term);\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function match(_x5, _x6) {\n        return _match.apply(this, arguments);\n      }\n\n      return match;\n    }()\n  }]);\n\n  return ProofPurpose;\n}();","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js"],"names":["module","exports","term","date","maxTimestampDelta","Infinity","undefined","Error","TypeError","Date","isNaN","proof","document","suite","verificationMethod","documentLoader","expansionMap","expected","getTime","delta","created","valid","error","proofPurpose"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class ProofPurpose {\n  /**\n   * @param term {string} the `proofPurpose` term, as defined in the\n   *    SECURITY_CONTEXT_URL `@context` or a URI if not defined in such.\n   * @param [date] {string or Date or integer} the expected date for\n   *   the creation of the proof.\n   * @param [maxTimestampDelta] {integer} a maximum number of seconds that\n   *   the date on the signature can deviate from, defaults to `Infinity`.\n   */\n  constructor({term, date, maxTimestampDelta = Infinity} = {}) {\n    if(term === undefined) {\n      throw new Error('\"term\" is required.');\n    }\n    if(maxTimestampDelta !== undefined &&\n      typeof maxTimestampDelta !== 'number') {\n      throw new TypeError('\"maxTimestampDelta\" must be a number.');\n    }\n    this.term = term;\n    if(date !== undefined) {\n      this.date = new Date(date);\n      if(isNaN(this.date)) {\n        throw TypeError(`\"date\" \"${date}\" is not a valid date.`);\n      }\n    }\n    this.maxTimestampDelta = maxTimestampDelta;\n  }\n\n  /**\n   * Called to validate the purpose of a proof. This method is called during\n   * proof verification, after the proof value has been checked against the\n   * given verification method (e.g. in the case of a digital signature, the\n   * signature has been cryptographically verified against the public key).\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`,\n   *   with the matching purpose to validate.\n   *\n   * @return {Promise<object>} resolves to an object with `valid` and `error`.\n   */\n  async validate(\n    proof, {document, suite, verificationMethod,\n      documentLoader, expansionMap}) {\n    try {\n      // check expiration\n      if(this.maxTimestampDelta !== Infinity) {\n        const expected = (this.date || new Date()).getTime();\n        const delta = this.maxTimestampDelta * 1000;\n        const created = new Date(proof.created).getTime();\n        // comparing this way handles NaN case where `created` is invalid\n        if(!(created >= (expected - delta) && created <= (expected + delta))) {\n          throw new Error('The proof\\'s created timestamp is out of range.');\n        }\n      }\n      return {valid: true};\n    } catch(error) {\n      return {valid: false, error};\n    }\n  }\n\n  /**\n   * Called to update a proof when it is being created, adding any properties\n   * specific to this purpose. This method is called prior to the proof\n   * value being generated such that any properties added may be, for example,\n   * included in a digital signature value.\n   *\n   * @param proof {object} the proof, in the `constants.SECURITY_CONTEXT_URL`\n   *   to update.\n   *\n   * @return {Promise<object>} resolves to the proof instance (in the\n   *   `constants.SECURITY_CONTEXT_URL`.\n   */\n  async update(proof, {document, suite, documentLoader, expansionMap}) {\n    proof.proofPurpose = this.term;\n    return proof;\n  }\n\n  /**\n   * Determines if the given proof has a purpose that matches this instance,\n   * i.e. this ProofPurpose instance should be used to validate the given\n   * proof.\n   *\n   * @param proof {object} the proof to check.\n   *\n   * @return {Promise<boolean>} `true` if there's a match, `false` if not.\n   */\n  async match(proof, {document, documentLoader, expansionMap}) {\n    return proof.proofPurpose === this.term;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}