{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar LinkedDataSignature = require('./LinkedDataSignature');\n\nvar jsonld = require('jsonld');\n\nvar util = require('../util');\n\nmodule.exports = /*#__PURE__*/function (_LinkedDataSignature) {\n  _inherits(JwsLinkedDataSignature, _LinkedDataSignature);\n\n  var _super = _createSuper(JwsLinkedDataSignature);\n\n  /**\n   * @param type {string} Provided by subclass.\n   * @param alg {string} JWS alg provided by subclass.\n   * @param [LDKeyClass] {LDKeyClass} provided by subclass or subclass\n   *   overrides `getVerificationMethod`.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * This parameter is required for signing:\n   *\n   * @param [signer] {function} an optional signer.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  function JwsLinkedDataSignature() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        type = _ref.type,\n        alg = _ref.alg,\n        LDKeyClass = _ref.LDKeyClass,\n        creator = _ref.creator,\n        verificationMethod = _ref.verificationMethod,\n        signer = _ref.signer,\n        key = _ref.key,\n        proof = _ref.proof,\n        date = _ref.date,\n        useNativeCanonize = _ref.useNativeCanonize;\n\n    _classCallCheck(this, JwsLinkedDataSignature);\n\n    _this = _super.call(this, {\n      type: type,\n      creator: creator,\n      verificationMethod: verificationMethod,\n      proof: proof,\n      date: date,\n      useNativeCanonize: useNativeCanonize\n    });\n    _this.alg = alg;\n    _this.LDKeyClass = LDKeyClass;\n    _this.signer = signer;\n\n    if (key) {\n      if (verificationMethod === undefined && creator === undefined) {\n        var publicKey = key.publicNode();\n\n        if (publicKey.owner) {\n          // use legacy signature terms\n          _this.creator = publicKey.id;\n        } else {\n          // use newer signature terms\n          _this.verificationMethod = publicKey.id;\n        }\n      }\n\n      _this.key = key;\n\n      if (typeof key.signer === 'function') {\n        _this.signer = key.signer();\n      }\n\n      if (typeof key.verifier === 'function') {\n        _this.verifier = key.verifier();\n      }\n    }\n\n    return _this;\n  }\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param proof {object}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n\n\n  _createClass(JwsLinkedDataSignature, [{\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n        var verifyData, proof, header, encodedHeader, data, signature, encodedSignature;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                verifyData = _ref2.verifyData, proof = _ref2.proof;\n\n                if (this.signer && typeof this.signer.sign === 'function') {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error('A signer API has not been specified.');\n\n              case 3:\n                // JWS header\n                header = {\n                  alg: this.alg,\n                  b64: false,\n                  crit: ['b64']\n                };\n                /*\n                +-------+-----------------------------------------------------------+\n                | \"b64\" | JWS Signing Input Formula                                 |\n                +-------+-----------------------------------------------------------+\n                | true  | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||     |\n                |       | BASE64URL(JWS Payload))                                   |\n                |       |                                                           |\n                | false | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.') ||    |\n                |       | JWS Payload                                               |\n                +-------+-----------------------------------------------------------+\n                */\n                // create JWS data and sign\n\n                encodedHeader = util.encodeBase64Url(JSON.stringify(header));\n                data = util.createJws({\n                  encodedHeader: encodedHeader,\n                  verifyData: verifyData\n                });\n                _context.next = 8;\n                return this.signer.sign({\n                  data: data\n                });\n\n              case 8:\n                signature = _context.sent;\n                // create detached content signature\n                encodedSignature = util.encodeBase64Url(signature);\n                proof.jws = encodedHeader + '..' + encodedSignature;\n                return _context.abrupt(\"return\", proof);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n    /**\n     * @param verifyData {Uint8Array}.\n     * @param verificationMethod {object}.\n     * @param document {object} the document the proof applies to.\n     * @param proof {object} the proof to be verified.\n     * @param purpose {ProofPurpose}\n     * @param documentLoader {function}\n     * @param expansionMap {function}\n     *\n     * @returns {Promise<{boolean}>} Resolves with the verification result.\n     */\n\n  }, {\n    key: \"verifySignature\",\n    value: function () {\n      var _verifySignature = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n        var verifyData, verificationMethod, proof, _proof$jws$split, _proof$jws$split2, encodedHeader, encodedSignature, header, signature, data, verifier, key;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                verifyData = _ref3.verifyData, verificationMethod = _ref3.verificationMethod, proof = _ref3.proof;\n\n                if (proof.jws && typeof proof.jws === 'string' && proof.jws.includes('.')) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new TypeError('The proof does not include a valid \"jws\" property.');\n\n              case 3:\n                // add payload into detached content signature\n                _proof$jws$split = proof.jws.split('.'), _proof$jws$split2 = _slicedToArray(_proof$jws$split, 3), encodedHeader = _proof$jws$split2[0], encodedSignature = _proof$jws$split2[2];\n                _context2.prev = 4;\n                header = JSON.parse(util.decodeBase64UrlToString(encodedHeader));\n                _context2.next = 11;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](4);\n                throw new Error('Could not parse JWS header; ' + _context2.t0);\n\n              case 11:\n                if (header && typeof header === 'object') {\n                  _context2.next = 13;\n                  break;\n                }\n\n                throw new Error('Invalid JWS header.');\n\n              case 13:\n                if (!(!(header.alg === this.alg && header.b64 === false && Array.isArray(header.crit) && header.crit.length === 1 && header.crit[0] === 'b64') && Object.keys(header).length === 3)) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                throw new Error(\"Invalid JWS header parameters for \".concat(this.type, \".\"));\n\n              case 15:\n                // do signature verification\n                signature = util.decodeBase64Url(encodedSignature);\n                data = util.createJws({\n                  encodedHeader: encodedHeader,\n                  verifyData: verifyData\n                });\n                verifier = this.verifier;\n\n                if (verifier) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                _context2.next = 21;\n                return this.LDKeyClass.from(verificationMethod);\n\n              case 21:\n                key = _context2.sent;\n                verifier = key.verifier();\n\n              case 23:\n                return _context2.abrupt(\"return\", verifier.verify({\n                  data: data,\n                  signature: signature\n                }));\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 8]]);\n      }));\n\n      function verifySignature(_x2) {\n        return _verifySignature.apply(this, arguments);\n      }\n\n      return verifySignature;\n    }()\n  }, {\n    key: \"assertVerificationMethod\",\n    value: function () {\n      var _assertVerificationMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4) {\n        var verificationMethod;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                verificationMethod = _ref4.verificationMethod;\n\n                if (jsonld.hasValue(verificationMethod, 'type', this.requiredKeyType)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid key type. Key type must be \\\"\".concat(this.requiredKeyType, \"\\\".\"));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function assertVerificationMethod(_x3) {\n        return _assertVerificationMethod.apply(this, arguments);\n      }\n\n      return assertVerificationMethod;\n    }()\n  }, {\n    key: \"getVerificationMethod\",\n    value: function () {\n      var _getVerificationMethod = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref5) {\n        var proof, documentLoader, verificationMethod;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                proof = _ref5.proof, documentLoader = _ref5.documentLoader;\n\n                if (!this.key) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", this.key.publicNode());\n\n              case 3:\n                _context4.next = 5;\n                return _get(_getPrototypeOf(JwsLinkedDataSignature.prototype), \"getVerificationMethod\", this).call(this, {\n                  proof: proof,\n                  documentLoader: documentLoader\n                });\n\n              case 5:\n                verificationMethod = _context4.sent;\n                _context4.next = 8;\n                return this.assertVerificationMethod({\n                  verificationMethod: verificationMethod\n                });\n\n              case 8:\n                return _context4.abrupt(\"return\", verificationMethod);\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getVerificationMethod(_x4) {\n        return _getVerificationMethod.apply(this, arguments);\n      }\n\n      return getVerificationMethod;\n    }()\n  }, {\n    key: \"matchProof\",\n    value: function () {\n      var _matchProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref6) {\n        var proof, document, purpose, documentLoader, expansionMap, verificationMethod;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                proof = _ref6.proof, document = _ref6.document, purpose = _ref6.purpose, documentLoader = _ref6.documentLoader, expansionMap = _ref6.expansionMap;\n                _context5.next = 3;\n                return _get(_getPrototypeOf(JwsLinkedDataSignature.prototype), \"matchProof\", this).call(this, {\n                  proof: proof,\n                  document: document,\n                  purpose: purpose,\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap\n                });\n\n              case 3:\n                if (_context5.sent) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 5:\n                if (this.key) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", true);\n\n              case 7:\n                verificationMethod = proof.verificationMethod;\n\n                if (!verificationMethod) {\n                  verificationMethod = proof.creator;\n                } // only match if the key specified matches the one in the proof\n\n\n                if (!(typeof verificationMethod === 'object')) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", verificationMethod.id === this.key.id);\n\n              case 11:\n                return _context5.abrupt(\"return\", verificationMethod === this.key.id);\n\n              case 12:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function matchProof(_x5) {\n        return _matchProof.apply(this, arguments);\n      }\n\n      return matchProof;\n    }()\n  }]);\n\n  return JwsLinkedDataSignature;\n}(LinkedDataSignature);","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld-signatures/lib/suites/JwsLinkedDataSignature.js"],"names":["LinkedDataSignature","require","jsonld","util","module","exports","type","alg","LDKeyClass","creator","verificationMethod","signer","key","proof","date","useNativeCanonize","undefined","publicKey","publicNode","owner","id","verifier","verifyData","sign","Error","header","b64","crit","encodedHeader","encodeBase64Url","JSON","stringify","data","createJws","signature","encodedSignature","jws","includes","TypeError","split","parse","decodeBase64UrlToString","Array","isArray","length","Object","keys","decodeBase64Url","from","verify","hasValue","requiredKeyType","documentLoader","assertVerificationMethod","document","purpose","expansionMap"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst LinkedDataSignature = require('./LinkedDataSignature');\nconst jsonld = require('jsonld');\nconst util = require('../util');\n\nmodule.exports = class JwsLinkedDataSignature extends LinkedDataSignature {\n  /**\n   * @param type {string} Provided by subclass.\n   * @param alg {string} JWS alg provided by subclass.\n   * @param [LDKeyClass] {LDKeyClass} provided by subclass or subclass\n   *   overrides `getVerificationMethod`.\n   *\n   * One of these parameters is required to use a suite for signing:\n   *\n   * @param [creator] {string} A key id URL to the paired public key.\n   * @param [verificationMethod] {string} A key id URL to the paired public key.\n   *\n   * This parameter is required for signing:\n   *\n   * @param [signer] {function} an optional signer.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [proof] {object} a JSON-LD document with options to use for\n   *   the `proof` node (e.g. any other custom fields can be provided here\n   *   using a context different from security-v2).\n   * @param [date] {string|Date} signing date to use if not passed.\n   * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n   * @param [useNativeCanonize] {boolean} true to use a native canonize\n   *   algorithm.\n   */\n  constructor({\n    type, alg, LDKeyClass, creator, verificationMethod, signer, key, proof,\n    date, useNativeCanonize} = {}) {\n    super({type, creator, verificationMethod, proof, date, useNativeCanonize});\n    this.alg = alg;\n    this.LDKeyClass = LDKeyClass;\n    this.signer = signer;\n    if(key) {\n      if(verificationMethod === undefined && creator === undefined) {\n        const publicKey = key.publicNode();\n        if(publicKey.owner) {\n          // use legacy signature terms\n          this.creator = publicKey.id;\n        } else {\n          // use newer signature terms\n          this.verificationMethod = publicKey.id;\n        }\n      }\n      this.key = key;\n      if(typeof key.signer === 'function') {\n        this.signer = key.signer();\n      }\n      if(typeof key.verifier === 'function') {\n        this.verifier = key.verifier();\n      }\n    }\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param proof {object}\n   *\n   * @returns {Promise<{object}>} the proof containing the signature value.\n   */\n  async sign({verifyData, proof}) {\n    if(!(this.signer && typeof this.signer.sign === 'function')) {\n      throw new Error('A signer API has not been specified.');\n    }\n    // JWS header\n    const header = {\n      alg: this.alg,\n      b64: false,\n      crit: ['b64']\n    };\n\n    /*\n    +-------+-----------------------------------------------------------+\n    | \"b64\" | JWS Signing Input Formula                                 |\n    +-------+-----------------------------------------------------------+\n    | true  | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||     |\n    |       | BASE64URL(JWS Payload))                                   |\n    |       |                                                           |\n    | false | ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.') ||    |\n    |       | JWS Payload                                               |\n    +-------+-----------------------------------------------------------+\n    */\n\n    // create JWS data and sign\n    const encodedHeader = util.encodeBase64Url(JSON.stringify(header));\n    const data = util.createJws({encodedHeader, verifyData});\n    const signature = await this.signer.sign({data});\n\n    // create detached content signature\n    const encodedSignature = util.encodeBase64Url(signature);\n    proof.jws = encodedHeader + '..' + encodedSignature;\n    return proof;\n  }\n\n  /**\n   * @param verifyData {Uint8Array}.\n   * @param verificationMethod {object}.\n   * @param document {object} the document the proof applies to.\n   * @param proof {object} the proof to be verified.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n  async verifySignature({verifyData, verificationMethod, proof}) {\n    if(!(proof.jws && typeof proof.jws === 'string' &&\n      proof.jws.includes('.'))) {\n      throw new TypeError('The proof does not include a valid \"jws\" property.');\n    }\n    // add payload into detached content signature\n    const [encodedHeader, /*payload*/, encodedSignature] = proof.jws.split('.');\n\n    let header;\n    try {\n      header = JSON.parse(util.decodeBase64UrlToString(encodedHeader));\n    } catch(e) {\n      throw new Error('Could not parse JWS header; ' + e);\n    }\n    if(!(header && typeof header === 'object')) {\n      throw new Error('Invalid JWS header.');\n    }\n\n    // confirm header matches all expectations\n    if(!(header.alg === this.alg && header.b64 === false &&\n      Array.isArray(header.crit) && header.crit.length === 1 &&\n      header.crit[0] === 'b64') && Object.keys(header).length === 3) {\n      throw new Error(\n        `Invalid JWS header parameters for ${this.type}.`);\n    }\n\n    // do signature verification\n    const signature = util.decodeBase64Url(encodedSignature);\n    const data = util.createJws({encodedHeader, verifyData});\n    let {verifier} = this;\n    if(!verifier) {\n      const key = await this.LDKeyClass.from(verificationMethod);\n      verifier = key.verifier();\n    }\n    return verifier.verify({data, signature});\n  }\n\n  async assertVerificationMethod({verificationMethod}) {\n    if(!jsonld.hasValue(verificationMethod, 'type', this.requiredKeyType)) {\n      throw new Error(\n        `Invalid key type. Key type must be \"${this.requiredKeyType}\".`);\n    }\n  }\n\n  async getVerificationMethod({proof, documentLoader}) {\n    if(this.key) {\n      return this.key.publicNode();\n    }\n\n    const verificationMethod = await super.getVerificationMethod(\n      {proof, documentLoader});\n    await this.assertVerificationMethod({verificationMethod});\n    return verificationMethod;\n  }\n\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    if(!await super.matchProof(\n      {proof, document, purpose, documentLoader, expansionMap})) {\n      return false;\n    }\n    if(!this.key) {\n      // no key specified, so assume this suite matches and it can be retrieved\n      return true;\n    }\n\n    let {verificationMethod} = proof;\n    if(!verificationMethod) {\n      verificationMethod = proof.creator;\n    }\n    // only match if the key specified matches the one in the proof\n    if(typeof verificationMethod === 'object') {\n      return verificationMethod.id === this.key.id;\n    }\n    return verificationMethod === this.key.id;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}