{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isEmptyObject = _require.isEmptyObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./graphTypes'),\n    _isList = _require2.isList,\n    _isValue = _require2.isValue,\n    _isGraph = _require2.isGraph;\n\nvar _require3 = require('./context'),\n    _expandIri = _require3.expandIri,\n    _getContextValue = _require3.getContextValue,\n    _isKeyword = _require3.isKeyword,\n    _processContext = _require3.process,\n    _processingMode = _require3.processingMode;\n\nvar _require4 = require('./url'),\n    _isAbsoluteIri = _require4.isAbsolute;\n\nvar _require5 = require('./util'),\n    _addValue = _require5.addValue,\n    _asArray = _require5.asArray,\n    _getValues = _require5.getValues,\n    _validateTypeValue = _require5.validateTypeValue;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\n\napi.expand = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$insideList, insideList, _ref$insideIndex, insideIndex, _ref$typeScopedContex, typeScopedContext, _ref$expansionMap, expansionMap, mapped, _rval, container, i, e, expandedActiveProperty, propertyScopedCtx, keys, mustRevert, _iterator, _step, key, expandedProperty, typeKey, _iterator2, _step2, _key, _expandedProperty, value, _types, _iterator3, _step3, type, ctx, rval, count, validCount, values, types, _mapped, _mapped2, _mapped3;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$insideList = _ref.insideList, insideList = _ref$insideList === void 0 ? false : _ref$insideList, _ref$insideIndex = _ref.insideIndex, insideIndex = _ref$insideIndex === void 0 ? false : _ref$insideIndex, _ref$typeScopedContex = _ref.typeScopedContext, typeScopedContext = _ref$typeScopedContex === void 0 ? null : _ref$typeScopedContex, _ref$expansionMap = _ref.expansionMap, expansionMap = _ref$expansionMap === void 0 ? function () {\n              return undefined;\n            } : _ref$expansionMap;\n\n            if (!(element === null || element === undefined)) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 3:\n            // disable framing if activeProperty is @default\n            if (activeProperty === '@default') {\n              options = Object.assign({}, options, {\n                isFrame: false\n              });\n            }\n\n            if (!(!_isArray(element) && !_isObject(element))) {\n              _context.next = 13;\n              break;\n            }\n\n            if (!(!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {\n              vocab: true\n            }, options) === '@graph'))) {\n              _context.next = 12;\n              break;\n            }\n\n            _context.next = 8;\n            return expansionMap({\n              unmappedValue: element,\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              options: options,\n              insideList: insideList\n            });\n\n          case 8:\n            mapped = _context.sent;\n\n            if (!(mapped === undefined)) {\n              _context.next = 11;\n              break;\n            }\n\n            return _context.abrupt(\"return\", null);\n\n          case 11:\n            return _context.abrupt(\"return\", mapped);\n\n          case 12:\n            return _context.abrupt(\"return\", _expandValue({\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              value: element,\n              options: options\n            }));\n\n          case 13:\n            if (!_isArray(element)) {\n              _context.next = 34;\n              break;\n            }\n\n            _rval = [];\n            container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n            insideList = insideList || container.includes('@list');\n            i = 0;\n\n          case 18:\n            if (!(i < element.length)) {\n              _context.next = 33;\n              break;\n            }\n\n            _context.next = 21;\n            return api.expand({\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              element: element[i],\n              options: options,\n              expansionMap: expansionMap,\n              insideIndex: insideIndex,\n              typeScopedContext: typeScopedContext\n            });\n\n          case 21:\n            e = _context.sent;\n\n            if (insideList && _isArray(e)) {\n              e = {\n                '@list': e\n              };\n            }\n\n            if (!(e === null)) {\n              _context.next = 29;\n              break;\n            }\n\n            _context.next = 26;\n            return expansionMap({\n              unmappedValue: element[i],\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              parent: element,\n              index: i,\n              options: options,\n              expandedParent: _rval,\n              insideList: insideList\n            });\n\n          case 26:\n            e = _context.sent;\n\n            if (!(e === undefined)) {\n              _context.next = 29;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 30);\n\n          case 29:\n            if (_isArray(e)) {\n              _rval = _rval.concat(e);\n            } else {\n              _rval.push(e);\n            }\n\n          case 30:\n            ++i;\n            _context.next = 18;\n            break;\n\n          case 33:\n            return _context.abrupt(\"return\", _rval);\n\n          case 34:\n            // recursively expand object:\n            // first, expand the active property\n            expandedActiveProperty = _expandIri(activeCtx, activeProperty, {\n              vocab: true\n            }, options); // Get any property-scoped context for activeProperty\n\n            propertyScopedCtx = _getContextValue(activeCtx, activeProperty, '@context'); // second, determine if any type-scoped context should be reverted; it\n            // should only be reverted when the following are all true:\n            // 1. `element` is not a value or subject reference\n            // 2. `insideIndex` is false\n\n            typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);\n            keys = Object.keys(element).sort();\n            mustRevert = !insideIndex;\n\n            if (!(mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes('@context'))) {\n              _context.next = 63;\n              break;\n            }\n\n            _iterator = _createForOfIteratorHelper(keys);\n            _context.prev = 41;\n\n            _iterator.s();\n\n          case 43:\n            if ((_step = _iterator.n()).done) {\n              _context.next = 55;\n              break;\n            }\n\n            key = _step.value;\n            expandedProperty = _expandIri(typeScopedContext, key, {\n              vocab: true\n            }, options);\n\n            if (!(expandedProperty === '@value')) {\n              _context.next = 50;\n              break;\n            }\n\n            // value found, ensure type-scoped context is used to expand it\n            mustRevert = false;\n            activeCtx = typeScopedContext;\n            return _context.abrupt(\"break\", 55);\n\n          case 50:\n            if (!(expandedProperty === '@id' && keys.length === 1)) {\n              _context.next = 53;\n              break;\n            }\n\n            // subject reference found, do not revert\n            mustRevert = false;\n            return _context.abrupt(\"break\", 55);\n\n          case 53:\n            _context.next = 43;\n            break;\n\n          case 55:\n            _context.next = 60;\n            break;\n\n          case 57:\n            _context.prev = 57;\n            _context.t0 = _context[\"catch\"](41);\n\n            _iterator.e(_context.t0);\n\n          case 60:\n            _context.prev = 60;\n\n            _iterator.f();\n\n            return _context.finish(60);\n\n          case 63:\n            if (mustRevert) {\n              // revert type scoped context\n              activeCtx = activeCtx.revertToPreviousContext();\n            } // apply property-scoped context after reverting term-scoped context\n\n\n            if (_isUndefined(propertyScopedCtx)) {\n              _context.next = 68;\n              break;\n            }\n\n            _context.next = 67;\n            return _processContext({\n              activeCtx: activeCtx,\n              localCtx: propertyScopedCtx,\n              propagate: true,\n              overrideProtected: true,\n              options: options\n            });\n\n          case 67:\n            activeCtx = _context.sent;\n\n          case 68:\n            if (!('@context' in element)) {\n              _context.next = 72;\n              break;\n            }\n\n            _context.next = 71;\n            return _processContext({\n              activeCtx: activeCtx,\n              localCtx: element['@context'],\n              options: options\n            });\n\n          case 71:\n            activeCtx = _context.sent;\n\n          case 72:\n            // set the type-scoped context to the context on input, for use later\n            typeScopedContext = activeCtx; // Remember the first key found expanding to @type\n\n            typeKey = null; // look for scoped contexts on `@type`\n\n            _iterator2 = _createForOfIteratorHelper(keys);\n            _context.prev = 75;\n\n            _iterator2.s();\n\n          case 77:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 106;\n              break;\n            }\n\n            _key = _step2.value;\n            _expandedProperty = _expandIri(activeCtx, _key, {\n              vocab: true\n            }, options);\n\n            if (!(_expandedProperty === '@type')) {\n              _context.next = 104;\n              break;\n            }\n\n            // set scoped contexts from @type\n            // avoid sorting if possible\n            typeKey = typeKey || _key;\n            value = element[_key];\n            _types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];\n            _iterator3 = _createForOfIteratorHelper(_types);\n            _context.prev = 85;\n\n            _iterator3.s();\n\n          case 87:\n            if ((_step3 = _iterator3.n()).done) {\n              _context.next = 96;\n              break;\n            }\n\n            type = _step3.value;\n            ctx = _getContextValue(typeScopedContext, type, '@context');\n\n            if (_isUndefined(ctx)) {\n              _context.next = 94;\n              break;\n            }\n\n            _context.next = 93;\n            return _processContext({\n              activeCtx: activeCtx,\n              localCtx: ctx,\n              options: options,\n              propagate: false\n            });\n\n          case 93:\n            activeCtx = _context.sent;\n\n          case 94:\n            _context.next = 87;\n            break;\n\n          case 96:\n            _context.next = 101;\n            break;\n\n          case 98:\n            _context.prev = 98;\n            _context.t1 = _context[\"catch\"](85);\n\n            _iterator3.e(_context.t1);\n\n          case 101:\n            _context.prev = 101;\n\n            _iterator3.f();\n\n            return _context.finish(101);\n\n          case 104:\n            _context.next = 77;\n            break;\n\n          case 106:\n            _context.next = 111;\n            break;\n\n          case 108:\n            _context.prev = 108;\n            _context.t2 = _context[\"catch\"](75);\n\n            _iterator2.e(_context.t2);\n\n          case 111:\n            _context.prev = 111;\n\n            _iterator2.f();\n\n            return _context.finish(111);\n\n          case 114:\n            // process each key and value in element, ignoring @nest content\n            rval = {};\n            _context.next = 117;\n            return _expandObject({\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              expandedActiveProperty: expandedActiveProperty,\n              element: element,\n              expandedParent: rval,\n              options: options,\n              insideList: insideList,\n              typeScopedContext: typeScopedContext,\n              typeKey: typeKey,\n              expansionMap: expansionMap\n            });\n\n          case 117:\n            // get property count on expanded output\n            keys = Object.keys(rval);\n            count = keys.length;\n\n            if (!('@value' in rval)) {\n              _context.next = 148;\n              break;\n            }\n\n            if (!('@type' in rval && '@language' in rval)) {\n              _context.next = 122;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may not ' + 'contain both \"@type\" and \"@language\".', 'jsonld.SyntaxError', {\n              code: 'invalid value object',\n              element: rval\n            });\n\n          case 122:\n            validCount = count - 1;\n\n            if ('@type' in rval) {\n              validCount -= 1;\n            }\n\n            if ('@index' in rval) {\n              validCount -= 1;\n            }\n\n            if ('@language' in rval) {\n              validCount -= 1;\n            }\n\n            if (!(validCount !== 0)) {\n              _context.next = 128;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may only ' + 'have an \"@index\" property and at most one other property ' + 'which can be \"@type\" or \"@language\".', 'jsonld.SyntaxError', {\n              code: 'invalid value object',\n              element: rval\n            });\n\n          case 128:\n            values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n            types = _getValues(rval, '@type'); // drop null @values unless custom mapped\n\n            if (!(_processingMode(activeCtx, 1.1) && types.includes('@json') && types.length === 1)) {\n              _context.next = 133;\n              break;\n            }\n\n            _context.next = 146;\n            break;\n\n          case 133:\n            if (!(values.length === 0)) {\n              _context.next = 140;\n              break;\n            }\n\n            _context.next = 136;\n            return expansionMap({\n              unmappedValue: rval,\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              element: element,\n              options: options,\n              insideList: insideList\n            });\n\n          case 136:\n            _mapped = _context.sent;\n\n            if (_mapped !== undefined) {\n              rval = _mapped;\n            } else {\n              rval = null;\n            }\n\n            _context.next = 146;\n            break;\n\n          case 140:\n            if (!(!values.every(function (v) {\n              return _isString(v) || _isEmptyObject(v);\n            }) && '@language' in rval)) {\n              _context.next = 144;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {\n              code: 'invalid language-tagged value',\n              element: rval\n            });\n\n          case 144:\n            if (types.every(function (t) {\n              return _isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) || _isEmptyObject(t);\n            })) {\n              _context.next = 146;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' + 'must have an absolute IRI for the value of \"@type\".', 'jsonld.SyntaxError', {\n              code: 'invalid typed value',\n              element: rval\n            });\n\n          case 146:\n            _context.next = 163;\n            break;\n\n          case 148:\n            if (!('@type' in rval && !_isArray(rval['@type']))) {\n              _context.next = 152;\n              break;\n            }\n\n            // convert @type to an array\n            rval['@type'] = [rval['@type']];\n            _context.next = 163;\n            break;\n\n          case 152:\n            if (!('@set' in rval || '@list' in rval)) {\n              _context.next = 158;\n              break;\n            }\n\n            if (!(count > 1 && !(count === 2 && '@index' in rval))) {\n              _context.next = 155;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property \"@set\" ' + 'or \"@list\", then it can have at most one other property that is ' + '\"@index\".', 'jsonld.SyntaxError', {\n              code: 'invalid set or list object',\n              element: rval\n            });\n\n          case 155:\n            // optimize away @set\n            if ('@set' in rval) {\n              rval = rval['@set'];\n              keys = Object.keys(rval);\n              count = keys.length;\n            }\n\n            _context.next = 163;\n            break;\n\n          case 158:\n            if (!(count === 1 && '@language' in rval)) {\n              _context.next = 163;\n              break;\n            }\n\n            _context.next = 161;\n            return expansionMap(rval, {\n              unmappedValue: rval,\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              element: element,\n              options: options,\n              insideList: insideList\n            });\n\n          case 161:\n            _mapped2 = _context.sent;\n\n            if (_mapped2 !== undefined) {\n              rval = _mapped2;\n            } else {\n              rval = null;\n            }\n\n          case 163:\n            if (!(_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph'))) {\n              _context.next = 169;\n              break;\n            }\n\n            if (!(count === 0 || '@value' in rval || '@list' in rval || count === 1 && '@id' in rval)) {\n              _context.next = 169;\n              break;\n            }\n\n            _context.next = 167;\n            return expansionMap({\n              unmappedValue: rval,\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              element: element,\n              options: options,\n              insideList: insideList\n            });\n\n          case 167:\n            _mapped3 = _context.sent;\n\n            if (_mapped3 !== undefined) {\n              rval = _mapped3;\n            } else {\n              rval = null;\n            }\n\n          case 169:\n            return _context.abrupt(\"return\", rval);\n\n          case 170:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[41, 57, 60, 63], [75, 108, 111, 114], [85, 98, 101, 104]]);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeScopedContext the context before reverting.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\n\n\nfunction _expandObject(_x2) {\n  return _expandObject2.apply(this, arguments);\n}\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\n\n\nfunction _expandObject2() {\n  _expandObject2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n    var activeCtx, activeProperty, expandedActiveProperty, element, expandedParent, _ref3$options, options, insideList, typeScopedContext, typeKey, expansionMap, keys, nests, unexpandedValue, isJsonType, _iterator6, _step6, _key2, value, expandedValue, expandedProperty, property, reverseMap, _property, items, ii, item, termCtx, ctx, container, asGraph, indexKey, propertyIndex, _asGraph, isList, nextActiveProperty, _reverseMap, _ii, _item, _i, _nests, key, nestedValues, _iterator7, _step7, nv;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            activeCtx = _ref3.activeCtx, activeProperty = _ref3.activeProperty, expandedActiveProperty = _ref3.expandedActiveProperty, element = _ref3.element, expandedParent = _ref3.expandedParent, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, insideList = _ref3.insideList, typeScopedContext = _ref3.typeScopedContext, typeKey = _ref3.typeKey, expansionMap = _ref3.expansionMap;\n            keys = Object.keys(element).sort();\n            nests = [];\n            // Figure out if this is the type for a JSON literal\n            isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], {\n              vocab: true\n            }, options) == '@json';\n            _iterator6 = _createForOfIteratorHelper(keys);\n            _context2.prev = 5;\n\n            _iterator6.s();\n\n          case 7:\n            if ((_step6 = _iterator6.n()).done) {\n              _context2.next = 165;\n              break;\n            }\n\n            _key2 = _step6.value;\n            value = element[_key2];\n            expandedValue = void 0; // skip @context\n\n            if (!(_key2 === '@context')) {\n              _context2.next = 13;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 13:\n            // expand property\n            expandedProperty = _expandIri(activeCtx, _key2, {\n              vocab: true\n            }, options); // drop non-absolute IRI keys that aren't keywords unless custom mapped\n\n            if (!(expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty)))) {\n              _context2.next = 18;\n              break;\n            }\n\n            // TODO: use `await` to support async\n            expandedProperty = expansionMap({\n              unmappedProperty: _key2,\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              parent: element,\n              options: options,\n              insideList: insideList,\n              value: value,\n              expandedParent: expandedParent\n            });\n\n            if (!(expandedProperty === undefined)) {\n              _context2.next = 18;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 18:\n            if (!_isKeyword(expandedProperty)) {\n              _context2.next = 23;\n              break;\n            }\n\n            if (!(expandedActiveProperty === '@reverse')) {\n              _context2.next = 21;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {\n              code: 'invalid reverse property map',\n              value: value\n            });\n\n          case 21:\n            if (!(expandedProperty in expandedParent)) {\n              _context2.next = 23;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {\n              code: 'colliding keywords',\n              keyword: expandedProperty\n            });\n\n          case 23:\n            if (!(expandedProperty === '@id')) {\n              _context2.next = 40;\n              break;\n            }\n\n            if (_isString(value)) {\n              _context2.next = 38;\n              break;\n            }\n\n            if (options.isFrame) {\n              _context2.next = 27;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value must a string.', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value: value\n            });\n\n          case 27:\n            if (!_isObject(value)) {\n              _context2.next = 32;\n              break;\n            }\n\n            if (_isEmptyObject(value)) {\n              _context2.next = 30;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value: value\n            });\n\n          case 30:\n            _context2.next = 38;\n            break;\n\n          case 32:\n            if (!_isArray(value)) {\n              _context2.next = 37;\n              break;\n            }\n\n            if (value.every(function (v) {\n              return _isString(v);\n            })) {\n              _context2.next = 35;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value: value\n            });\n\n          case 35:\n            _context2.next = 38;\n            break;\n\n          case 37:\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n              code: 'invalid @id value',\n              value: value\n            });\n\n          case 38:\n            _addValue(expandedParent, '@id', _asArray(value).map(function (v) {\n              return _isString(v) ? _expandIri(activeCtx, v, {\n                base: true\n              }, options) : v;\n            }), {\n              propertyIsArray: options.isFrame\n            });\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 40:\n            if (!(expandedProperty === '@type')) {\n              _context2.next = 44;\n              break;\n            }\n\n            _validateTypeValue(value);\n\n            _addValue(expandedParent, '@type', _asArray(value).map(function (v) {\n              return _isString(v) ? _expandIri(typeScopedContext, v, {\n                base: true,\n                vocab: true\n              }, options) : v;\n            }), {\n              propertyIsArray: options.isFrame\n            });\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 44:\n            if (!(expandedProperty === '@graph' && !(_isObject(value) || _isArray(value)))) {\n              _context2.next = 46;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@graph\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n              code: 'invalid @graph value',\n              value: value\n            });\n\n          case 46:\n            if (!(expandedProperty === '@value')) {\n              _context2.next = 50;\n              break;\n            }\n\n            // capture value for later\n            // \"colliding keywords\" check prevents this from being set twice\n            unexpandedValue = value;\n\n            if (isJsonType && _processingMode(activeCtx, 1.1)) {\n              // no coercion to array, and retain all values\n              expandedParent['@value'] = value;\n            } else {\n              _addValue(expandedParent, '@value', value, {\n                propertyIsArray: options.isFrame\n              });\n            }\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 50:\n            if (!(expandedProperty === '@language')) {\n              _context2.next = 58;\n              break;\n            }\n\n            if (!(value === null)) {\n              _context2.next = 53;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 53:\n            if (!(!_isString(value) && !options.isFrame)) {\n              _context2.next = 55;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@language\" value must be a string.', 'jsonld.SyntaxError', {\n              code: 'invalid language-tagged string',\n              value: value\n            });\n\n          case 55:\n            // ensure language value is lowercase\n            value = _asArray(value).map(function (v) {\n              return _isString(v) ? v.toLowerCase() : v;\n            });\n\n            _addValue(expandedParent, '@language', value, {\n              propertyIsArray: options.isFrame\n            });\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 58:\n            if (!(expandedProperty === '@index')) {\n              _context2.next = 63;\n              break;\n            }\n\n            if (_isString(value)) {\n              _context2.next = 61;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@index\" value must be a string.', 'jsonld.SyntaxError', {\n              code: 'invalid @index value',\n              value: value\n            });\n\n          case 61:\n            _addValue(expandedParent, '@index', value);\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 63:\n            if (!(expandedProperty === '@reverse')) {\n              _context2.next = 91;\n              break;\n            }\n\n            if (_isObject(value)) {\n              _context2.next = 66;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must be an object.', 'jsonld.SyntaxError', {\n              code: 'invalid @reverse value',\n              value: value\n            });\n\n          case 66:\n            _context2.next = 68;\n            return api.expand({\n              activeCtx: activeCtx,\n              activeProperty: '@reverse',\n              element: value,\n              options: options,\n              expansionMap: expansionMap\n            });\n\n          case 68:\n            expandedValue = _context2.sent;\n\n            // properties double-reversed\n            if ('@reverse' in expandedValue) {\n              for (property in expandedValue['@reverse']) {\n                _addValue(expandedParent, property, expandedValue['@reverse'][property], {\n                  propertyIsArray: true\n                });\n              }\n            } // FIXME: can this be merged with code below to simplify?\n            // merge in all reversed properties\n\n\n            reverseMap = expandedParent['@reverse'] || null;\n            _context2.t0 = _regeneratorRuntime.keys(expandedValue);\n\n          case 72:\n            if ((_context2.t1 = _context2.t0()).done) {\n              _context2.next = 90;\n              break;\n            }\n\n            _property = _context2.t1.value;\n\n            if (!(_property === '@reverse')) {\n              _context2.next = 76;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 72);\n\n          case 76:\n            if (reverseMap === null) {\n              reverseMap = expandedParent['@reverse'] = {};\n            }\n\n            _addValue(reverseMap, _property, [], {\n              propertyIsArray: true\n            });\n\n            items = expandedValue[_property];\n            ii = 0;\n\n          case 80:\n            if (!(ii < items.length)) {\n              _context2.next = 88;\n              break;\n            }\n\n            item = items[ii];\n\n            if (!(_isValue(item) || _isList(item))) {\n              _context2.next = 84;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n              code: 'invalid reverse property value',\n              value: expandedValue\n            });\n\n          case 84:\n            _addValue(reverseMap, _property, item, {\n              propertyIsArray: true\n            });\n\n          case 85:\n            ++ii;\n            _context2.next = 80;\n            break;\n\n          case 88:\n            _context2.next = 72;\n            break;\n\n          case 90:\n            return _context2.abrupt(\"continue\", 163);\n\n          case 91:\n            if (!(expandedProperty === '@nest')) {\n              _context2.next = 94;\n              break;\n            }\n\n            nests.push(_key2);\n            return _context2.abrupt(\"continue\", 163);\n\n          case 94:\n            // use potential scoped context for key\n            termCtx = activeCtx;\n            ctx = _getContextValue(activeCtx, _key2, '@context');\n\n            if (_isUndefined(ctx)) {\n              _context2.next = 100;\n              break;\n            }\n\n            _context2.next = 99;\n            return _processContext({\n              activeCtx: activeCtx,\n              localCtx: ctx,\n              propagate: true,\n              overrideProtected: true,\n              options: options\n            });\n\n          case 99:\n            termCtx = _context2.sent;\n\n          case 100:\n            container = _getContextValue(termCtx, _key2, '@container') || [];\n\n            if (!(container.includes('@language') && _isObject(value))) {\n              _context2.next = 105;\n              break;\n            }\n\n            // handle language map container (skip if value is not an object)\n            expandedValue = _expandLanguageMap(termCtx, value, options);\n            _context2.next = 143;\n            break;\n\n          case 105:\n            if (!(container.includes('@index') && _isObject(value))) {\n              _context2.next = 114;\n              break;\n            }\n\n            // handle index container (skip if value is not an object)\n            asGraph = container.includes('@graph');\n            indexKey = _getContextValue(termCtx, _key2, '@index') || '@index';\n            propertyIndex = indexKey !== '@index' && _expandIri(activeCtx, indexKey, {\n              vocab: true\n            }, options);\n            _context2.next = 111;\n            return _expandIndexMap({\n              activeCtx: termCtx,\n              options: options,\n              activeProperty: _key2,\n              value: value,\n              expansionMap: expansionMap,\n              asGraph: asGraph,\n              indexKey: indexKey,\n              propertyIndex: propertyIndex\n            });\n\n          case 111:\n            expandedValue = _context2.sent;\n            _context2.next = 143;\n            break;\n\n          case 114:\n            if (!(container.includes('@id') && _isObject(value))) {\n              _context2.next = 121;\n              break;\n            }\n\n            // handle id container (skip if value is not an object)\n            _asGraph = container.includes('@graph');\n            _context2.next = 118;\n            return _expandIndexMap({\n              activeCtx: termCtx,\n              options: options,\n              activeProperty: _key2,\n              value: value,\n              expansionMap: expansionMap,\n              asGraph: _asGraph,\n              indexKey: '@id'\n            });\n\n          case 118:\n            expandedValue = _context2.sent;\n            _context2.next = 143;\n            break;\n\n          case 121:\n            if (!(container.includes('@type') && _isObject(value))) {\n              _context2.next = 127;\n              break;\n            }\n\n            _context2.next = 124;\n            return _expandIndexMap({\n              // since container is `@type`, revert type scoped context when expanding\n              activeCtx: termCtx.revertToPreviousContext(),\n              options: options,\n              activeProperty: _key2,\n              value: value,\n              expansionMap: expansionMap,\n              asGraph: false,\n              indexKey: '@type'\n            });\n\n          case 124:\n            expandedValue = _context2.sent;\n            _context2.next = 143;\n            break;\n\n          case 127:\n            // recurse into @list or @set\n            isList = expandedProperty === '@list';\n\n            if (!(isList || expandedProperty === '@set')) {\n              _context2.next = 136;\n              break;\n            }\n\n            nextActiveProperty = activeProperty;\n\n            if (isList && expandedActiveProperty === '@graph') {\n              nextActiveProperty = null;\n            }\n\n            _context2.next = 133;\n            return api.expand({\n              activeCtx: termCtx,\n              activeProperty: nextActiveProperty,\n              element: value,\n              options: options,\n              insideList: isList,\n              expansionMap: expansionMap\n            });\n\n          case 133:\n            expandedValue = _context2.sent;\n            _context2.next = 143;\n            break;\n\n          case 136:\n            if (!(_getContextValue(activeCtx, _key2, '@type') === '@json')) {\n              _context2.next = 140;\n              break;\n            }\n\n            expandedValue = {\n              '@type': '@json',\n              '@value': value\n            };\n            _context2.next = 143;\n            break;\n\n          case 140:\n            _context2.next = 142;\n            return api.expand({\n              activeCtx: termCtx,\n              activeProperty: _key2,\n              element: value,\n              options: options,\n              insideList: false,\n              expansionMap: expansionMap\n            });\n\n          case 142:\n            expandedValue = _context2.sent;\n\n          case 143:\n            if (!(expandedValue === null && expandedProperty !== '@value')) {\n              _context2.next = 147;\n              break;\n            }\n\n            // TODO: use `await` to support async\n            expandedValue = expansionMap({\n              unmappedValue: value,\n              expandedProperty: expandedProperty,\n              activeCtx: termCtx,\n              activeProperty: activeProperty,\n              parent: element,\n              options: options,\n              insideList: insideList,\n              key: _key2,\n              expandedParent: expandedParent\n            });\n\n            if (!(expandedValue === undefined)) {\n              _context2.next = 147;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 163);\n\n          case 147:\n            // convert expanded value to @list if container specifies it\n            if (expandedProperty !== '@list' && !_isList(expandedValue) && container.includes('@list')) {\n              // ensure expanded value in @list is an array\n              expandedValue = {\n                '@list': _asArray(expandedValue)\n              };\n            } // convert expanded value to @graph if container specifies it\n            // and value is not, itself, a graph\n            // index cases handled above\n\n\n            if (container.includes('@graph') && !container.some(function (key) {\n              return key === '@id' || key === '@index';\n            })) {\n              // ensure expanded values are arrays\n              expandedValue = _asArray(expandedValue).map(function (v) {\n                return {\n                  '@graph': _asArray(v)\n                };\n              });\n            } // FIXME: can this be merged with code above to simplify?\n            // merge in reverse properties\n\n\n            if (!(termCtx.mappings.has(_key2) && termCtx.mappings.get(_key2).reverse)) {\n              _context2.next = 162;\n              break;\n            }\n\n            _reverseMap = expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n            expandedValue = _asArray(expandedValue);\n            _ii = 0;\n\n          case 153:\n            if (!(_ii < expandedValue.length)) {\n              _context2.next = 161;\n              break;\n            }\n\n            _item = expandedValue[_ii];\n\n            if (!(_isValue(_item) || _isList(_item))) {\n              _context2.next = 157;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n              code: 'invalid reverse property value',\n              value: expandedValue\n            });\n\n          case 157:\n            _addValue(_reverseMap, expandedProperty, _item, {\n              propertyIsArray: true\n            });\n\n          case 158:\n            ++_ii;\n            _context2.next = 153;\n            break;\n\n          case 161:\n            return _context2.abrupt(\"continue\", 163);\n\n          case 162:\n            // add value for property\n            // special keywords handled above\n            _addValue(expandedParent, expandedProperty, expandedValue, {\n              propertyIsArray: true\n            });\n\n          case 163:\n            _context2.next = 7;\n            break;\n\n          case 165:\n            _context2.next = 170;\n            break;\n\n          case 167:\n            _context2.prev = 167;\n            _context2.t2 = _context2[\"catch\"](5);\n\n            _iterator6.e(_context2.t2);\n\n          case 170:\n            _context2.prev = 170;\n\n            _iterator6.f();\n\n            return _context2.finish(170);\n\n          case 173:\n            if (!('@value' in expandedParent)) {\n              _context2.next = 179;\n              break;\n            }\n\n            if (!(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1))) {\n              _context2.next = 177;\n              break;\n            }\n\n            _context2.next = 179;\n            break;\n\n          case 177:\n            if (!((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame)) {\n              _context2.next = 179;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; \"@value\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n              code: 'invalid value object value',\n              value: unexpandedValue\n            });\n\n          case 179:\n            _i = 0, _nests = nests;\n\n          case 180:\n            if (!(_i < _nests.length)) {\n              _context2.next = 205;\n              break;\n            }\n\n            key = _nests[_i];\n            nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n            _iterator7 = _createForOfIteratorHelper(nestedValues);\n            _context2.prev = 184;\n\n            _iterator7.s();\n\n          case 186:\n            if ((_step7 = _iterator7.n()).done) {\n              _context2.next = 194;\n              break;\n            }\n\n            nv = _step7.value;\n\n            if (!(!_isObject(nv) || Object.keys(nv).some(function (k) {\n              return _expandIri(activeCtx, k, {\n                vocab: true\n              }, options) === '@value';\n            }))) {\n              _context2.next = 190;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; nested value must be a node object.', 'jsonld.SyntaxError', {\n              code: 'invalid @nest value',\n              value: nv\n            });\n\n          case 190:\n            _context2.next = 192;\n            return _expandObject({\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              expandedActiveProperty: expandedActiveProperty,\n              element: nv,\n              expandedParent: expandedParent,\n              options: options,\n              insideList: insideList,\n              typeKey: typeKey,\n              expansionMap: expansionMap\n            });\n\n          case 192:\n            _context2.next = 186;\n            break;\n\n          case 194:\n            _context2.next = 199;\n            break;\n\n          case 196:\n            _context2.prev = 196;\n            _context2.t3 = _context2[\"catch\"](184);\n\n            _iterator7.e(_context2.t3);\n\n          case 199:\n            _context2.prev = 199;\n\n            _iterator7.f();\n\n            return _context2.finish(199);\n\n          case 202:\n            _i++;\n            _context2.next = 180;\n            break;\n\n          case 205:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[5, 167, 170, 173], [184, 196, 199, 202]]);\n  }));\n  return _expandObject2.apply(this, arguments);\n}\n\nfunction _expandValue(_ref4) {\n  var activeCtx = _ref4.activeCtx,\n      activeProperty = _ref4.activeProperty,\n      value = _ref4.value,\n      options = _ref4.options;\n\n  // nothing to expand\n  if (value === null || value === undefined) {\n    return null;\n  } // special-case expand @id and @type (skips '@id' expansion)\n\n\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  if (expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {\n      base: true\n    }, options);\n  } else if (expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {\n      vocab: true,\n      base: true\n    }, options);\n  } // get type definition from context\n\n\n  var type = _getContextValue(activeCtx, activeProperty, '@type'); // do @id expansion (automatic for @graph)\n\n\n  if ((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        base: true\n      }, options)\n    };\n  } // do @id expansion w/vocab\n\n\n  if (type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        vocab: true,\n        base: true\n      }, options)\n    };\n  } // do not expand keyword values\n\n\n  if (_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  var rval = {};\n\n  if (type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if (_isString(value)) {\n    // check for language tagging for strings\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    if (language !== null) {\n      rval['@language'] = language;\n    }\n  } // do conversion of values that aren't basic JSON types to strings\n\n\n  if (!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n\n  rval['@value'] = value;\n  return rval;\n}\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\n\n\nfunction _expandLanguageMap(activeCtx, languageMap, options) {\n  var rval = [];\n  var keys = Object.keys(languageMap).sort();\n\n  var _iterator4 = _createForOfIteratorHelper(keys),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var key = _step4.value;\n\n      var expandedKey = _expandIri(activeCtx, key, {\n        vocab: true\n      }, options);\n\n      var val = languageMap[key];\n\n      if (!_isArray(val)) {\n        val = [val];\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(val),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var item = _step5.value;\n\n          if (item === null) {\n            // null values are allowed (8.5) but ignored (3.1)\n            continue;\n          }\n\n          if (!_isString(item)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {\n              code: 'invalid language map value',\n              languageMap: languageMap\n            });\n          }\n\n          var _val = {\n            '@value': item\n          };\n\n          if (expandedKey !== '@none') {\n            _val['@language'] = key.toLowerCase();\n          }\n\n          rval.push(_val);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return rval;\n}\n\nfunction _expandIndexMap(_x3) {\n  return _expandIndexMap2.apply(this, arguments);\n}\n\nfunction _expandIndexMap2() {\n  _expandIndexMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5) {\n    var activeCtx, options, activeProperty, value, expansionMap, asGraph, indexKey, propertyIndex, rval, keys, isTypeIndex, _iterator8, _step8, key, ctx, val, expandedKey, _iterator9, _step9, item;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            activeCtx = _ref5.activeCtx, options = _ref5.options, activeProperty = _ref5.activeProperty, value = _ref5.value, expansionMap = _ref5.expansionMap, asGraph = _ref5.asGraph, indexKey = _ref5.indexKey, propertyIndex = _ref5.propertyIndex;\n            rval = [];\n            keys = Object.keys(value).sort();\n            isTypeIndex = indexKey === '@type';\n            _iterator8 = _createForOfIteratorHelper(keys);\n            _context3.prev = 5;\n\n            _iterator8.s();\n\n          case 7:\n            if ((_step8 = _iterator8.n()).done) {\n              _context3.next = 51;\n              break;\n            }\n\n            key = _step8.value;\n\n            if (!isTypeIndex) {\n              _context3.next = 15;\n              break;\n            }\n\n            ctx = _getContextValue(activeCtx, key, '@context');\n\n            if (_isUndefined(ctx)) {\n              _context3.next = 15;\n              break;\n            }\n\n            _context3.next = 14;\n            return _processContext({\n              activeCtx: activeCtx,\n              localCtx: ctx,\n              propagate: false,\n              options: options\n            });\n\n          case 14:\n            activeCtx = _context3.sent;\n\n          case 15:\n            val = value[key];\n\n            if (!_isArray(val)) {\n              val = [val];\n            }\n\n            _context3.next = 19;\n            return api.expand({\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              element: val,\n              options: options,\n              insideList: false,\n              insideIndex: true,\n              expansionMap: expansionMap\n            });\n\n          case 19:\n            val = _context3.sent;\n            // expand for @type, but also for @none\n            expandedKey = void 0;\n\n            if (propertyIndex) {\n              if (key === '@none') {\n                expandedKey = '@none';\n              } else {\n                expandedKey = _expandValue({\n                  activeCtx: activeCtx,\n                  activeProperty: indexKey,\n                  value: key,\n                  options: options\n                });\n              }\n            } else {\n              expandedKey = _expandIri(activeCtx, key, {\n                vocab: true\n              }, options);\n            }\n\n            if (indexKey === '@id') {\n              // expand document relative\n              key = _expandIri(activeCtx, key, {\n                base: true\n              }, options);\n            } else if (isTypeIndex) {\n              key = expandedKey;\n            }\n\n            _iterator9 = _createForOfIteratorHelper(val);\n            _context3.prev = 24;\n\n            _iterator9.s();\n\n          case 26:\n            if ((_step9 = _iterator9.n()).done) {\n              _context3.next = 41;\n              break;\n            }\n\n            item = _step9.value;\n\n            // If this is also a @graph container, turn items into graphs\n            if (asGraph && !_isGraph(item)) {\n              item = {\n                '@graph': [item]\n              };\n            }\n\n            if (!(indexKey === '@type')) {\n              _context3.next = 33;\n              break;\n            }\n\n            if (expandedKey === '@none') {// ignore @none\n            } else if (item['@type']) {\n              item['@type'] = [key].concat(item['@type']);\n            } else {\n              item['@type'] = [key];\n            }\n\n            _context3.next = 38;\n            break;\n\n          case 33:\n            if (!(_isValue(item) && !['@language', '@type', '@index'].includes(indexKey))) {\n              _context3.next = 37;\n              break;\n            }\n\n            throw new JsonLdError('Invalid JSON-LD syntax; Attempt to add illegal key to value ' + \"object: \\\"\".concat(indexKey, \"\\\".\"), 'jsonld.SyntaxError', {\n              code: 'invalid value object',\n              value: item\n            });\n\n          case 37:\n            if (propertyIndex) {\n              // index is a property to be expanded, and values interpreted for that\n              // property\n              if (expandedKey !== '@none') {\n                // expand key as a value\n                _addValue(item, propertyIndex, expandedKey, {\n                  propertyIsArray: true,\n                  prependValue: true\n                });\n              }\n            } else if (expandedKey !== '@none' && !(indexKey in item)) {\n              item[indexKey] = key;\n            }\n\n          case 38:\n            rval.push(item);\n\n          case 39:\n            _context3.next = 26;\n            break;\n\n          case 41:\n            _context3.next = 46;\n            break;\n\n          case 43:\n            _context3.prev = 43;\n            _context3.t0 = _context3[\"catch\"](24);\n\n            _iterator9.e(_context3.t0);\n\n          case 46:\n            _context3.prev = 46;\n\n            _iterator9.f();\n\n            return _context3.finish(46);\n\n          case 49:\n            _context3.next = 7;\n            break;\n\n          case 51:\n            _context3.next = 56;\n            break;\n\n          case 53:\n            _context3.prev = 53;\n            _context3.t1 = _context3[\"catch\"](5);\n\n            _iterator8.e(_context3.t1);\n\n          case 56:\n            _context3.prev = 56;\n\n            _iterator8.f();\n\n            return _context3.finish(56);\n\n          case 59:\n            return _context3.abrupt(\"return\", rval);\n\n          case 60:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[5, 53, 56, 59], [24, 43, 46, 49]]);\n  }));\n  return _expandIndexMap2.apply(this, arguments);\n}","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld/lib/expand.js"],"names":["JsonLdError","require","_isArray","isArray","_isObject","isObject","_isEmptyObject","isEmptyObject","_isString","isString","_isUndefined","isUndefined","_isList","isList","_isValue","isValue","_isGraph","isGraph","_expandIri","expandIri","_getContextValue","getContextValue","_isKeyword","isKeyword","_processContext","process","_processingMode","processingMode","_isAbsoluteIri","isAbsolute","_addValue","addValue","_asArray","asArray","_getValues","getValues","_validateTypeValue","validateTypeValue","api","module","exports","expand","activeCtx","activeProperty","element","options","insideList","insideIndex","typeScopedContext","expansionMap","undefined","Object","assign","isFrame","vocab","unmappedValue","mapped","_expandValue","value","rval","container","includes","i","length","e","parent","index","expandedParent","concat","push","expandedActiveProperty","propertyScopedCtx","previousContext","keys","sort","mustRevert","key","expandedProperty","revertToPreviousContext","localCtx","propagate","overrideProtected","typeKey","types","Array","slice","type","ctx","_expandObject","count","code","validCount","values","every","v","t","indexOf","keepFreeFloatingNodes","nests","isJsonType","expandedValue","unmappedProperty","keyword","map","base","propertyIsArray","unexpandedValue","toLowerCase","property","reverseMap","items","ii","item","termCtx","_expandLanguageMap","asGraph","indexKey","propertyIndex","_expandIndexMap","nextActiveProperty","some","mappings","has","get","reverse","nestedValues","nv","k","language","toString","languageMap","expandedKey","val","isTypeIndex","prependValue"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null,\n  expansionMap = () => undefined\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists unless custom mapped\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      const mapped = await expansionMap({\n        unmappedValue: element,\n        activeCtx,\n        activeProperty,\n        options,\n        insideList\n      });\n      if(mapped === undefined) {\n        return null;\n      }\n      return mapped;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        expansionMap,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        e = await expansionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options,\n          expandedParent: rval,\n          insideList\n        });\n        if(e === undefined) {\n          continue;\n        }\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx =\n    _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if(!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = await _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeScopedContext,\n    typeKey,\n    expansionMap});\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && '@language' in rval) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and \"@language\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and at most one other property ' +\n        'which can be \"@type\" or \"@language\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values unless custom mapped\n    if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(values.length === 0) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language unless custom mapped\n    const mapped = await expansionMap(rval, {\n      unmappedValue: rval,\n      activeCtx,\n      activeProperty,\n      element,\n      options,\n      insideList\n    });\n    if(mapped !== undefined) {\n      rval = mapped;\n    } else {\n      rval = null;\n    }\n  }\n\n  // drop certain top-level objects that do not occur in lists, unless custom\n  // mapped\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null || expandedActiveProperty === '@graph')) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    if(count === 0 || '@value' in rval || '@list' in rval ||\n      (count === 1 && '@id' in rval)) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeScopedContext the context before reverting.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeScopedContext,\n  typeKey,\n  expansionMap\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] &&\n    _expandIri(activeCtx,\n      (_isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey]),\n      {vocab: true}, options) == '@json';\n\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    let expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords unless custom mapped\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      // TODO: use `await` to support async\n      expandedProperty = expansionMap({\n        unmappedProperty: key,\n        activeCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        value,\n        expandedParent\n      });\n      if(expandedProperty === undefined) {\n        continue;\n      }\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v =>\n          _isString(v) ? _expandIri(activeCtx, v, {base: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      _validateTypeValue(value);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v =>\n          _isString(v) ?\n            _expandIri(typeScopedContext, v,\n              {base: true, vocab: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if(isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(\n          expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      }\n      continue;\n    }\n\n    // @language must be a string\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty:\n        '@reverse',\n        element: value,\n        options,\n        expansionMap\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(termCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' &&\n        _expandIri(activeCtx, indexKey, {vocab: true}, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = (expandedProperty === '@list');\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList,\n          expansionMap\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false,\n          expansionMap\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // TODO: use `await` to support async\n      expandedValue = expansionMap({\n        unmappedValue: value,\n        expandedProperty,\n        activeCtx: termCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        key,\n        expandedParent\n      });\n      if(expandedValue === undefined) {\n        continue;\n      }\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      expandedValue = _asArray(expandedValue)\n        .map(v => ({'@graph': _asArray(v)}));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in expandedParent) {\n    if(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(unexpandedValue) || _isArray(unexpandedValue)) &&\n      !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value: unexpandedValue});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeKey,\n        expansionMap});\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true}, options);\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {'@id': _expandIri(activeCtx, value, {base: true}, options)};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        val['@language'] = key.toLowerCase();\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nasync function _expandIndexMap(\n  {activeCtx, options, activeProperty, value, expansionMap, asGraph,\n    indexKey, propertyIndex}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true,\n      expansionMap\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if(propertyIndex) {\n      if(key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue(\n          {activeCtx, activeProperty: indexKey, value: key, options});\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    }\n\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(_isValue(item) &&\n        !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; Attempt to add illegal key to value ' +\n          `object: \"${indexKey}\".`,\n          'jsonld.SyntaxError',\n          {code: 'invalid value object', value: item});\n      } else if(propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if(expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n"]},"metadata":{},"sourceType":"script"}