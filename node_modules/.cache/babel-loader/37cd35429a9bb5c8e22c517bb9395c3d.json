{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('../util'),\n    parseLinkHeader = _require.parseLinkHeader,\n    buildHeaders = _require.buildHeaders;\n\nvar _require2 = require('../constants'),\n    LINK_HEADER_REL = _require2.LINK_HEADER_REL;\n\nvar JsonLdError = require('../JsonLdError');\n\nvar RequestQueue = require('../RequestQueue');\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\n\n\nmodule.exports = function () {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n    strictSSL: true,\n    maxRedirects: -1,\n    headers: {}\n  },\n      secure = _ref.secure,\n      _ref$strictSSL = _ref.strictSSL,\n      strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,\n      _ref$maxRedirects = _ref.maxRedirects,\n      maxRedirects = _ref$maxRedirects === void 0 ? -1 : _ref$maxRedirects,\n      request = _ref.request,\n      _ref$headers = _ref.headers,\n      headers = _ref$headers === void 0 ? {} : _ref$headers;\n\n  headers = buildHeaders(headers); // TODO: use `axios`\n\n  request = request || require('request');\n\n  var http = require('http');\n\n  var queue = new RequestQueue();\n  return queue.wrapLoader(function (url) {\n    return loadDocument(url, []);\n  });\n\n  function loadDocument(_x, _x2) {\n    return _loadDocument.apply(this, arguments);\n  }\n\n  function _loadDocument() {\n    _loadDocument = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, redirects) {\n      var doc, result, _result, res, body, statusText, linkHeader;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0)) {\n                _context.next = 2;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; only \"http\" and \"https\" URLs are ' + 'supported.', 'jsonld.InvalidUrl', {\n                code: 'loading document failed',\n                url: url\n              });\n\n            case 2:\n              if (!(secure && url.indexOf('https') !== 0)) {\n                _context.next = 4;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; secure mode is enabled and ' + 'the URL\\'s scheme is not \"https\".', 'jsonld.InvalidUrl', {\n                code: 'loading document failed',\n                url: url\n              });\n\n            case 4:\n              // TODO: disable cache until HTTP caching implemented\n              doc = null; //cache.get(url);\n\n              if (!(doc !== null)) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\", doc);\n\n            case 7:\n              _context.prev = 7;\n              _context.next = 10;\n              return _request(request, {\n                url: url,\n                headers: headers,\n                strictSSL: strictSSL,\n                followRedirect: false\n              });\n\n            case 10:\n              result = _context.sent;\n              _context.next = 16;\n              break;\n\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](7);\n              throw new JsonLdError('URL could not be dereferenced, an error occurred.', 'jsonld.LoadDocumentError', {\n                code: 'loading document failed',\n                url: url,\n                cause: _context.t0\n              });\n\n            case 16:\n              _result = result, res = _result.res, body = _result.body;\n              doc = {\n                contextUrl: null,\n                documentUrl: url,\n                document: body || null\n              }; // handle error\n\n              statusText = http.STATUS_CODES[res.statusCode];\n\n              if (!(res.statusCode >= 400)) {\n                _context.next = 21;\n                break;\n              }\n\n              throw new JsonLdError(\"URL \\\"\".concat(url, \"\\\" could not be dereferenced: \").concat(statusText), 'jsonld.InvalidUrl', {\n                code: 'loading document failed',\n                url: url,\n                httpStatusCode: res.statusCode\n              });\n\n            case 21:\n              if (!(res.headers.link && res.headers['content-type'] !== 'application/ld+json')) {\n                _context.next = 26;\n                break;\n              }\n\n              // only 1 related link header permitted\n              linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];\n\n              if (!Array.isArray(linkHeader)) {\n                _context.next = 25;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced, it has more than one associated ' + 'HTTP Link Header.', 'jsonld.InvalidUrl', {\n                code: 'multiple context link headers',\n                url: url\n              });\n\n            case 25:\n              if (linkHeader) {\n                doc.contextUrl = linkHeader.target;\n              }\n\n            case 26:\n              if (!(res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)) {\n                _context.next = 33;\n                break;\n              }\n\n              if (!(redirects.length === maxRedirects)) {\n                _context.next = 29;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; there were too many redirects.', 'jsonld.TooManyRedirects', {\n                code: 'loading document failed',\n                url: url,\n                httpStatusCode: res.statusCode,\n                redirects: redirects\n              });\n\n            case 29:\n              if (!(redirects.indexOf(url) !== -1)) {\n                _context.next = 31;\n                break;\n              }\n\n              throw new JsonLdError('URL could not be dereferenced; infinite redirection was detected.', 'jsonld.InfiniteRedirectDetected', {\n                code: 'recursive context inclusion',\n                url: url,\n                httpStatusCode: res.statusCode,\n                redirects: redirects\n              });\n\n            case 31:\n              redirects.push(url);\n              return _context.abrupt(\"return\", loadDocument(res.headers.location, redirects));\n\n            case 33:\n              // cache for each redirected URL\n              redirects.push(url); // TODO: disable cache until HTTP caching implemented\n\n              /*\n              for(let i = 0; i < redirects.length; ++i) {\n                cache.set(\n                  redirects[i],\n                  {contextUrl: null, documentUrl: redirects[i], document: body});\n              }\n              */\n\n              return _context.abrupt(\"return\", doc);\n\n            case 35:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[7, 13]]);\n    }));\n    return _loadDocument.apply(this, arguments);\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise(function (resolve, reject) {\n    request(options, function (err, res, body) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({\n          res: res,\n          body: body\n        });\n      }\n    });\n  });\n}","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld/lib/documentLoaders/node.js"],"names":["require","parseLinkHeader","buildHeaders","LINK_HEADER_REL","JsonLdError","RequestQueue","module","exports","strictSSL","maxRedirects","headers","secure","request","http","queue","wrapLoader","url","loadDocument","redirects","indexOf","code","doc","_request","followRedirect","result","cause","res","body","contextUrl","documentUrl","document","statusText","STATUS_CODES","statusCode","httpStatusCode","link","linkHeader","Array","isArray","target","location","length","push","options","Promise","resolve","reject","err"],"mappings":"AAAA;AACA;AACA;AACA;;;;;;AAEA,eAAwCA,OAAO,CAAC,SAAD,CAA/C;AAAA,IAAOC,eAAP,YAAOA,eAAP;AAAA,IAAwBC,YAAxB,YAAwBA,YAAxB;;AACA,gBAA0BF,OAAO,CAAC,cAAD,CAAjC;AAAA,IAAOG,eAAP,aAAOA,eAAP;;AACA,IAAMC,WAAW,GAAGJ,OAAO,CAAC,gBAAD,CAA3B;;AACA,IAAMK,YAAY,GAAGL,OAAO,CAAC,iBAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAM,MAAM,CAACC,OAAP,GAAiB,YAMwC;AAAA,iFAArD;AAACC,IAAAA,SAAS,EAAE,IAAZ;AAAkBC,IAAAA,YAAY,EAAE,CAAC,CAAjC;AAAoCC,IAAAA,OAAO,EAAE;AAA7C,GAAqD;AAAA,MALvDC,MAKuD,QALvDA,MAKuD;AAAA,4BAJvDH,SAIuD;AAAA,MAJvDA,SAIuD,+BAJ3C,IAI2C;AAAA,+BAHvDC,YAGuD;AAAA,MAHvDA,YAGuD,kCAHxC,CAAC,CAGuC;AAAA,MAFvDG,OAEuD,QAFvDA,OAEuD;AAAA,0BADvDF,OACuD;AAAA,MADvDA,OACuD,6BAD7C,EAC6C;;AACvDA,EAAAA,OAAO,GAAGR,YAAY,CAACQ,OAAD,CAAtB,CADuD,CAEvD;;AACAE,EAAAA,OAAO,GAAGA,OAAO,IAAIZ,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAMa,IAAI,GAAGb,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMc,KAAK,GAAG,IAAIT,YAAJ,EAAd;AACA,SAAOS,KAAK,CAACC,UAAN,CAAiB,UAASC,GAAT,EAAc;AACpC,WAAOC,YAAY,CAACD,GAAD,EAAM,EAAN,CAAnB;AACD,GAFM,CAAP;;AAPuD,WAWxCC,YAXwC;AAAA;AAAA;;AAAA;AAAA,6EAWvD,iBAA4BD,GAA5B,EAAiCE,SAAjC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,oBACKF,GAAG,CAACG,OAAJ,CAAY,OAAZ,MAAyB,CAAzB,IAA8BH,GAAG,CAACG,OAAJ,CAAY,QAAZ,MAA0B,CAD7D;AAAA;AAAA;AAAA;;AAAA,oBAEU,IAAIf,WAAJ,CACJ,qEACA,YAFI,EAGJ,mBAHI,EAGiB;AAACgB,gBAAAA,IAAI,EAAE,yBAAP;AAAkCJ,gBAAAA,GAAG,EAAHA;AAAlC,eAHjB,CAFV;;AAAA;AAAA,oBAOKL,MAAM,IAAIK,GAAG,CAACG,OAAJ,CAAY,OAAZ,MAAyB,CAPxC;AAAA;AAAA;AAAA;;AAAA,oBAQU,IAAIf,WAAJ,CACJ,+DACA,mCAFI,EAGJ,mBAHI,EAGiB;AAACgB,gBAAAA,IAAI,EAAE,yBAAP;AAAkCJ,gBAAAA,GAAG,EAAHA;AAAlC,eAHjB,CARV;;AAAA;AAaE;AACIK,cAAAA,GAdN,GAcY,IAdZ,EAciB;;AAdjB,oBAeKA,GAAG,KAAK,IAfb;AAAA;AAAA;AAAA;;AAAA,+CAgBWA,GAhBX;;AAAA;AAAA;AAAA;AAAA,qBAqBmBC,QAAQ,CAACV,OAAD,EAAU;AAC/BI,gBAAAA,GAAG,EAAHA,GAD+B;AAE/BN,gBAAAA,OAAO,EAAPA,OAF+B;AAG/BF,gBAAAA,SAAS,EAATA,SAH+B;AAI/Be,gBAAAA,cAAc,EAAE;AAJe,eAAV,CArB3B;;AAAA;AAqBIC,cAAAA,MArBJ;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,oBA4BU,IAAIpB,WAAJ,CACJ,mDADI,EAEJ,0BAFI,EAGJ;AAACgB,gBAAAA,IAAI,EAAE,yBAAP;AAAkCJ,gBAAAA,GAAG,EAAHA,GAAlC;AAAuCS,gBAAAA,KAAK;AAA5C,eAHI,CA5BV;;AAAA;AAAA,wBAkCsBD,MAlCtB,EAkCSE,GAlCT,WAkCSA,GAlCT,EAkCcC,IAlCd,WAkCcA,IAlCd;AAoCEN,cAAAA,GAAG,GAAG;AAACO,gBAAAA,UAAU,EAAE,IAAb;AAAmBC,gBAAAA,WAAW,EAAEb,GAAhC;AAAqCc,gBAAAA,QAAQ,EAAEH,IAAI,IAAI;AAAvD,eAAN,CApCF,CAsCE;;AACMI,cAAAA,UAvCR,GAuCqBlB,IAAI,CAACmB,YAAL,CAAkBN,GAAG,CAACO,UAAtB,CAvCrB;;AAAA,oBAwCKP,GAAG,CAACO,UAAJ,IAAkB,GAxCvB;AAAA;AAAA;AAAA;;AAAA,oBAyCU,IAAI7B,WAAJ,iBACIY,GADJ,2CACuCe,UADvC,GAEJ,mBAFI,EAEiB;AACnBX,gBAAAA,IAAI,EAAE,yBADa;AAEnBJ,gBAAAA,GAAG,EAAHA,GAFmB;AAGnBkB,gBAAAA,cAAc,EAAER,GAAG,CAACO;AAHD,eAFjB,CAzCV;;AAAA;AAAA,oBAmDKP,GAAG,CAAChB,OAAJ,CAAYyB,IAAZ,IACDT,GAAG,CAAChB,OAAJ,CAAY,cAAZ,MAAgC,qBApDpC;AAAA;AAAA;AAAA;;AAqDI;AACM0B,cAAAA,UAtDV,GAsDuBnC,eAAe,CAACyB,GAAG,CAAChB,OAAJ,CAAYyB,IAAb,CAAf,CAAkChC,eAAlC,CAtDvB;;AAAA,mBAuDOkC,KAAK,CAACC,OAAN,CAAcF,UAAd,CAvDP;AAAA;AAAA;AAAA;;AAAA,oBAwDY,IAAIhC,WAAJ,CACJ,oEACA,mBAFI,EAGJ,mBAHI,EAIJ;AAACgB,gBAAAA,IAAI,EAAE,+BAAP;AAAwCJ,gBAAAA,GAAG,EAAHA;AAAxC,eAJI,CAxDZ;;AAAA;AA8DI,kBAAGoB,UAAH,EAAe;AACbf,gBAAAA,GAAG,CAACO,UAAJ,GAAiBQ,UAAU,CAACG,MAA5B;AACD;;AAhEL;AAAA,oBAoEKb,GAAG,CAACO,UAAJ,IAAkB,GAAlB,IAAyBP,GAAG,CAACO,UAAJ,GAAiB,GAA1C,IAAiDP,GAAG,CAAChB,OAAJ,CAAY8B,QApElE;AAAA;AAAA;AAAA;;AAAA,oBAqEOtB,SAAS,CAACuB,MAAV,KAAqBhC,YArE5B;AAAA;AAAA;AAAA;;AAAA,oBAsEY,IAAIL,WAAJ,CACJ,+DADI,EAEJ,yBAFI,EAEuB;AACzBgB,gBAAAA,IAAI,EAAE,yBADmB;AAEzBJ,gBAAAA,GAAG,EAAHA,GAFyB;AAGzBkB,gBAAAA,cAAc,EAAER,GAAG,CAACO,UAHK;AAIzBf,gBAAAA,SAAS,EAATA;AAJyB,eAFvB,CAtEZ;;AAAA;AAAA,oBA+EOA,SAAS,CAACC,OAAV,CAAkBH,GAAlB,MAA2B,CAAC,CA/EnC;AAAA;AAAA;AAAA;;AAAA,oBAgFY,IAAIZ,WAAJ,CACJ,mEADI,EAEJ,iCAFI,EAE+B;AACjCgB,gBAAAA,IAAI,EAAE,6BAD2B;AAEjCJ,gBAAAA,GAAG,EAAHA,GAFiC;AAGjCkB,gBAAAA,cAAc,EAAER,GAAG,CAACO,UAHa;AAIjCf,gBAAAA,SAAS,EAATA;AAJiC,eAF/B,CAhFZ;;AAAA;AAyFIA,cAAAA,SAAS,CAACwB,IAAV,CAAe1B,GAAf;AAzFJ,+CA0FWC,YAAY,CAACS,GAAG,CAAChB,OAAJ,CAAY8B,QAAb,EAAuBtB,SAAvB,CA1FvB;;AAAA;AA6FE;AACAA,cAAAA,SAAS,CAACwB,IAAV,CAAe1B,GAAf,EA9FF,CA+FE;;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AAtGE,+CAwGSK,GAxGT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAXuD;AAAA;AAAA;AAqHxD,CA3HD;;AA6HA,SAASC,QAAT,CAAkBV,OAAlB,EAA2B+B,OAA3B,EAAoC;AAClC,SAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtClC,IAAAA,OAAO,CAAC+B,OAAD,EAAU,UAACI,GAAD,EAAMrB,GAAN,EAAWC,IAAX,EAAoB;AACnC,UAAGoB,GAAH,EAAQ;AACND,QAAAA,MAAM,CAACC,GAAD,CAAN;AACD,OAFD,MAEO;AACLF,QAAAA,OAAO,CAAC;AAACnB,UAAAA,GAAG,EAAHA,GAAD;AAAMC,UAAAA,IAAI,EAAJA;AAAN,SAAD,CAAP;AACD;AACF,KANM,CAAP;AAOD,GARM,CAAP;AASD","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {parseLinkHeader, buildHeaders} = require('../util');\nconst {LINK_HEADER_REL} = require('../constants');\nconst JsonLdError = require('../JsonLdError');\nconst RequestQueue = require('../RequestQueue');\n\n/**\n * Creates a built-in node document loader.\n *\n * @param options the options to use:\n *          secure: require all URLs to use HTTPS.\n *          strictSSL: true to require SSL certificates to be valid,\n *            false not to (default: true).\n *          maxRedirects: the maximum number of redirects to permit, none by\n *            default.\n *          request: the object which will make the request, default is\n *            provided by `https://www.npmjs.com/package/request`.\n *          headers: an object (map) of headers which will be passed as request\n *            headers for the requested document. Accept is not allowed.\n *\n * @return the node document loader.\n */\nmodule.exports = ({\n  secure,\n  strictSSL = true,\n  maxRedirects = -1,\n  request,\n  headers = {}\n} = {strictSSL: true, maxRedirects: -1, headers: {}}) => {\n  headers = buildHeaders(headers);\n  // TODO: use `axios`\n  request = request || require('request');\n  const http = require('http');\n\n  const queue = new RequestQueue();\n  return queue.wrapLoader(function(url) {\n    return loadDocument(url, []);\n  });\n\n  async function loadDocument(url, redirects) {\n    if(url.indexOf('http:') !== 0 && url.indexOf('https:') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; only \"http\" and \"https\" URLs are ' +\n        'supported.',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    if(secure && url.indexOf('https') !== 0) {\n      throw new JsonLdError(\n        'URL could not be dereferenced; secure mode is enabled and ' +\n        'the URL\\'s scheme is not \"https\".',\n        'jsonld.InvalidUrl', {code: 'loading document failed', url});\n    }\n    // TODO: disable cache until HTTP caching implemented\n    let doc = null;//cache.get(url);\n    if(doc !== null) {\n      return doc;\n    }\n\n    let result;\n    try {\n      result = await _request(request, {\n        url,\n        headers,\n        strictSSL,\n        followRedirect: false\n      });\n    } catch(e) {\n      throw new JsonLdError(\n        'URL could not be dereferenced, an error occurred.',\n        'jsonld.LoadDocumentError',\n        {code: 'loading document failed', url, cause: e});\n    }\n\n    const {res, body} = result;\n\n    doc = {contextUrl: null, documentUrl: url, document: body || null};\n\n    // handle error\n    const statusText = http.STATUS_CODES[res.statusCode];\n    if(res.statusCode >= 400) {\n      throw new JsonLdError(\n        `URL \"${url}\" could not be dereferenced: ${statusText}`,\n        'jsonld.InvalidUrl', {\n          code: 'loading document failed',\n          url,\n          httpStatusCode: res.statusCode\n        });\n    }\n\n    // handle Link Header\n    if(res.headers.link &&\n      res.headers['content-type'] !== 'application/ld+json') {\n      // only 1 related link header permitted\n      const linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];\n      if(Array.isArray(linkHeader)) {\n        throw new JsonLdError(\n          'URL could not be dereferenced, it has more than one associated ' +\n          'HTTP Link Header.',\n          'jsonld.InvalidUrl',\n          {code: 'multiple context link headers', url});\n      }\n      if(linkHeader) {\n        doc.contextUrl = linkHeader.target;\n      }\n    }\n\n    // handle redirect\n    if(res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      if(redirects.length === maxRedirects) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; there were too many redirects.',\n          'jsonld.TooManyRedirects', {\n            code: 'loading document failed',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      if(redirects.indexOf(url) !== -1) {\n        throw new JsonLdError(\n          'URL could not be dereferenced; infinite redirection was detected.',\n          'jsonld.InfiniteRedirectDetected', {\n            code: 'recursive context inclusion',\n            url,\n            httpStatusCode: res.statusCode,\n            redirects\n          });\n      }\n      redirects.push(url);\n      return loadDocument(res.headers.location, redirects);\n    }\n\n    // cache for each redirected URL\n    redirects.push(url);\n    // TODO: disable cache until HTTP caching implemented\n    /*\n    for(let i = 0; i < redirects.length; ++i) {\n      cache.set(\n        redirects[i],\n        {contextUrl: null, documentUrl: redirects[i], document: body});\n    }\n    */\n\n    return doc;\n  }\n};\n\nfunction _request(request, options) {\n  return new Promise((resolve, reject) => {\n    request(options, (err, res, body) => {\n      if(err) {\n        reject(err);\n      } else {\n        resolve({res, body});\n      }\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"script"}