{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toArray = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _defineProperty = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _createForOfIteratorHelper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar JsonLdError = require('./JsonLdError');\n\nvar _require = require('./types'),\n    _isArray = _require.isArray,\n    _isObject = _require.isObject,\n    _isString = _require.isString,\n    _isUndefined = _require.isUndefined;\n\nvar _require2 = require('./graphTypes'),\n    _isList = _require2.isList,\n    _isValue = _require2.isValue,\n    _isGraph = _require2.isGraph,\n    _isSimpleGraph = _require2.isSimpleGraph,\n    _isSubjectReference = _require2.isSubjectReference;\n\nvar _require3 = require('./context'),\n    _expandIri = _require3.expandIri,\n    _getContextValue = _require3.getContextValue,\n    _isKeyword = _require3.isKeyword,\n    _processContext = _require3.process,\n    _processingMode = _require3.processingMode;\n\nvar _require4 = require('./url'),\n    _removeBase = _require4.removeBase;\n\nvar _require5 = require('./util'),\n    _addValue = _require5.addValue,\n    _asArray = _require5.asArray,\n    _compareShortestLeast = _require5.compareShortestLeast;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\n\napi.compact = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$compactionMap, compactionMap, rval, i, compacted, container, ctx, _ret;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$compactionMap = _ref.compactionMap, compactionMap = _ref$compactionMap === void 0 ? function () {\n              return undefined;\n            } : _ref$compactionMap;\n\n            if (!_isArray(element)) {\n              _context2.next = 20;\n              break;\n            }\n\n            rval = [];\n            i = 0;\n\n          case 4:\n            if (!(i < element.length)) {\n              _context2.next = 18;\n              break;\n            }\n\n            _context2.next = 7;\n            return api.compact({\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              element: element[i],\n              options: options,\n              compactionMap: compactionMap\n            });\n\n          case 7:\n            compacted = _context2.sent;\n\n            if (!(compacted === null)) {\n              _context2.next = 14;\n              break;\n            }\n\n            _context2.next = 11;\n            return compactionMap({\n              unmappedValue: element[i],\n              activeCtx: activeCtx,\n              activeProperty: activeProperty,\n              parent: element,\n              index: i,\n              options: options\n            });\n\n          case 11:\n            compacted = _context2.sent;\n\n            if (!(compacted === undefined)) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 15);\n\n          case 14:\n            rval.push(compacted);\n\n          case 15:\n            ++i;\n            _context2.next = 4;\n            break;\n\n          case 18:\n            if (options.compactArrays && rval.length === 1) {\n              // use single element if no container is specified\n              container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n              if (container.length === 0) {\n                rval = rval[0];\n              }\n            }\n\n            return _context2.abrupt(\"return\", rval);\n\n          case 20:\n            // use any scoped context on activeProperty\n            ctx = _getContextValue(activeCtx, activeProperty, '@context');\n\n            if (_isUndefined(ctx)) {\n              _context2.next = 25;\n              break;\n            }\n\n            _context2.next = 24;\n            return _processContext({\n              activeCtx: activeCtx,\n              localCtx: ctx,\n              propagate: true,\n              overrideProtected: true,\n              options: options\n            });\n\n          case 24:\n            activeCtx = _context2.sent;\n\n          case 25:\n            if (!_isObject(element)) {\n              _context2.next = 30;\n              break;\n            }\n\n            return _context2.delegateYield( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var linked, _i, _rval, _container, insideReverse, rval, inputCtx, propertyScopedCtx, types, typeContext, _iterator, _step, type, compactedType, _ctx, keys, _iterator2, _step2, expandedProperty, expandedValue, compactedValue, alias, _compactedValue, _alias, _container2, typeAsSet, isArray, _compactedValue2, compactedProperty, value, _container3, useArray, _alias2, _compactedValue3, _container4, _alias3, _alias4, itemActiveProperty, nestProperty, nestResult, _iterator3, _step3, expandedItem, _itemActiveProperty, _nestProperty, _nestResult, _container5, isGraph, isList, inner, compactedItem, mapObject, key, _mapObject, _key, indexKey, containerKey, others, _asArray2, _asArray3, idKey, typeKey, _types, _asArray4, _asArray5, _isArray2;\n\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      if (!(options.link && '@id' in element && options.link.hasOwnProperty(element['@id']))) {\n                        _context.next = 9;\n                        break;\n                      }\n\n                      // check for a linked element to reuse\n                      linked = options.link[element['@id']];\n                      _i = 0;\n\n                    case 3:\n                      if (!(_i < linked.length)) {\n                        _context.next = 9;\n                        break;\n                      }\n\n                      if (!(linked[_i].expanded === element)) {\n                        _context.next = 6;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", {\n                        v: linked[_i].compacted\n                      });\n\n                    case 6:\n                      ++_i;\n                      _context.next = 3;\n                      break;\n\n                    case 9:\n                      if (!(_isValue(element) || _isSubjectReference(element))) {\n                        _context.next = 13;\n                        break;\n                      }\n\n                      _rval = api.compactValue({\n                        activeCtx: activeCtx,\n                        activeProperty: activeProperty,\n                        value: element,\n                        options: options\n                      });\n\n                      if (options.link && _isSubjectReference(element)) {\n                        // store linked element\n                        if (!options.link.hasOwnProperty(element['@id'])) {\n                          options.link[element['@id']] = [];\n                        }\n\n                        options.link[element['@id']].push({\n                          expanded: element,\n                          compacted: _rval\n                        });\n                      }\n\n                      return _context.abrupt(\"return\", {\n                        v: _rval\n                      });\n\n                    case 13:\n                      if (!_isList(element)) {\n                        _context.next = 17;\n                        break;\n                      }\n\n                      _container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n                      if (!_container.includes('@list')) {\n                        _context.next = 17;\n                        break;\n                      }\n\n                      return _context.abrupt(\"return\", {\n                        v: api.compact({\n                          activeCtx: activeCtx,\n                          activeProperty: activeProperty,\n                          element: element['@list'],\n                          options: options,\n                          compactionMap: compactionMap\n                        })\n                      });\n\n                    case 17:\n                      // FIXME: avoid misuse of active property as an expanded property?\n                      insideReverse = activeProperty === '@reverse';\n                      rval = {}; // original context before applying property-scoped and local contexts\n\n                      inputCtx = activeCtx; // revert to previous context, if there is one,\n                      // and element is not a value object or a node reference\n\n                      if (!_isValue(element) && !_isSubjectReference(element)) {\n                        activeCtx = activeCtx.revertToPreviousContext();\n                      } // apply property-scoped context after reverting term-scoped context\n\n\n                      propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');\n\n                      if (_isUndefined(propertyScopedCtx)) {\n                        _context.next = 26;\n                        break;\n                      }\n\n                      _context.next = 25;\n                      return _processContext({\n                        activeCtx: activeCtx,\n                        localCtx: propertyScopedCtx,\n                        propagate: true,\n                        overrideProtected: true,\n                        options: options\n                      });\n\n                    case 25:\n                      activeCtx = _context.sent;\n\n                    case 26:\n                      if (options.link && '@id' in element) {\n                        // store linked element\n                        if (!options.link.hasOwnProperty(element['@id'])) {\n                          options.link[element['@id']] = [];\n                        }\n\n                        options.link[element['@id']].push({\n                          expanded: element,\n                          compacted: rval\n                        });\n                      } // apply any context defined on an alias of @type\n                      // if key is @type and any compacted value is a term having a local\n                      // context, overlay that context\n\n\n                      types = element['@type'] || [];\n\n                      if (types.length > 1) {\n                        types = Array.from(types).sort();\n                      } // find all type-scoped contexts based on current context, prior to\n                      // updating it\n\n\n                      typeContext = activeCtx;\n                      _iterator = _createForOfIteratorHelper(types);\n                      _context.prev = 31;\n\n                      _iterator.s();\n\n                    case 33:\n                      if ((_step = _iterator.n()).done) {\n                        _context.next = 43;\n                        break;\n                      }\n\n                      type = _step.value;\n                      compactedType = api.compactIri({\n                        activeCtx: typeContext,\n                        iri: type,\n                        relativeTo: {\n                          vocab: true\n                        }\n                      }); // Use any type-scoped context defined on this value\n\n                      _ctx = _getContextValue(inputCtx, compactedType, '@context');\n\n                      if (_isUndefined(_ctx)) {\n                        _context.next = 41;\n                        break;\n                      }\n\n                      _context.next = 40;\n                      return _processContext({\n                        activeCtx: activeCtx,\n                        localCtx: _ctx,\n                        options: options,\n                        propagate: false\n                      });\n\n                    case 40:\n                      activeCtx = _context.sent;\n\n                    case 41:\n                      _context.next = 33;\n                      break;\n\n                    case 43:\n                      _context.next = 48;\n                      break;\n\n                    case 45:\n                      _context.prev = 45;\n                      _context.t0 = _context[\"catch\"](31);\n\n                      _iterator.e(_context.t0);\n\n                    case 48:\n                      _context.prev = 48;\n\n                      _iterator.f();\n\n                      return _context.finish(48);\n\n                    case 51:\n                      // process element keys in order\n                      keys = Object.keys(element).sort();\n                      _iterator2 = _createForOfIteratorHelper(keys);\n                      _context.prev = 53;\n\n                      _iterator2.s();\n\n                    case 55:\n                      if ((_step2 = _iterator2.n()).done) {\n                        _context.next = 211;\n                        break;\n                      }\n\n                      expandedProperty = _step2.value;\n                      expandedValue = element[expandedProperty]; // compact @id\n\n                      if (!(expandedProperty === '@id')) {\n                        _context.next = 64;\n                        break;\n                      }\n\n                      compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n                        return api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: expandedIri,\n                          relativeTo: {\n                            vocab: false\n                          }\n                        });\n                      });\n\n                      if (compactedValue.length === 1) {\n                        compactedValue = compactedValue[0];\n                      } // use keyword alias and add value\n\n\n                      alias = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@id',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n                      rval[alias] = compactedValue;\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 64:\n                      if (!(expandedProperty === '@type')) {\n                        _context.next = 73;\n                        break;\n                      }\n\n                      // resolve type values against previous context\n                      _compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n                        return api.compactIri({\n                          activeCtx: inputCtx,\n                          iri: expandedIri,\n                          relativeTo: {\n                            vocab: true\n                          }\n                        });\n                      });\n\n                      if (_compactedValue.length === 1) {\n                        _compactedValue = _compactedValue[0];\n                      } // use keyword alias and add value\n\n\n                      _alias = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@type',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n                      _container2 = _getContextValue(activeCtx, _alias, '@container') || []; // treat as array for @type if @container includes @set\n\n                      typeAsSet = _container2.includes('@set') && _processingMode(activeCtx, 1.1);\n                      isArray = typeAsSet || _isArray(_compactedValue) && expandedValue.length === 0;\n\n                      _addValue(rval, _alias, _compactedValue, {\n                        propertyIsArray: isArray\n                      });\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 73:\n                      if (!(expandedProperty === '@reverse')) {\n                        _context.next = 80;\n                        break;\n                      }\n\n                      _context.next = 76;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: '@reverse',\n                        element: expandedValue,\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 76:\n                      _compactedValue2 = _context.sent;\n\n                      // handle double-reversed properties\n                      for (compactedProperty in _compactedValue2) {\n                        if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n                          value = _compactedValue2[compactedProperty];\n                          _container3 = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n                          useArray = _container3.includes('@set') || !options.compactArrays;\n\n                          _addValue(rval, compactedProperty, value, {\n                            propertyIsArray: useArray\n                          });\n\n                          delete _compactedValue2[compactedProperty];\n                        }\n                      }\n\n                      if (Object.keys(_compactedValue2).length > 0) {\n                        // use keyword alias and add value\n                        _alias2 = api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: expandedProperty,\n                          relativeTo: {\n                            vocab: true\n                          }\n                        });\n\n                        _addValue(rval, _alias2, _compactedValue2);\n                      }\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 80:\n                      if (!(expandedProperty === '@preserve')) {\n                        _context.next = 86;\n                        break;\n                      }\n\n                      _context.next = 83;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: activeProperty,\n                        element: expandedValue,\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 83:\n                      _compactedValue3 = _context.sent;\n\n                      if (!(_isArray(_compactedValue3) && _compactedValue3.length === 0)) {\n                        _addValue(rval, expandedProperty, _compactedValue3);\n                      }\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 86:\n                      if (!(expandedProperty === '@index')) {\n                        _context.next = 93;\n                        break;\n                      }\n\n                      // drop @index if inside an @index container\n                      _container4 = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n                      if (!_container4.includes('@index')) {\n                        _context.next = 90;\n                        break;\n                      }\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 90:\n                      // use keyword alias and add value\n                      _alias3 = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: expandedProperty,\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n\n                      _addValue(rval, _alias3, expandedValue);\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 93:\n                      if (!(expandedProperty !== '@graph' && expandedProperty !== '@list' && _isKeyword(expandedProperty))) {\n                        _context.next = 97;\n                        break;\n                      }\n\n                      // use keyword alias and add value as is\n                      _alias4 = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: expandedProperty,\n                        relativeTo: {\n                          vocab: true\n                        }\n                      });\n\n                      _addValue(rval, _alias4, expandedValue);\n\n                      return _context.abrupt(\"continue\", 209);\n\n                    case 97:\n                      if (_isArray(expandedValue)) {\n                        _context.next = 99;\n                        break;\n                      }\n\n                      throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n\n                    case 99:\n                      // preserve empty arrays\n                      if (expandedValue.length === 0) {\n                        itemActiveProperty = api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: expandedProperty,\n                          value: expandedValue,\n                          relativeTo: {\n                            vocab: true\n                          },\n                          reverse: insideReverse\n                        });\n                        nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n                        nestResult = rval;\n\n                        if (nestProperty) {\n                          _checkNestProperty(activeCtx, nestProperty, options);\n\n                          if (!_isObject(rval[nestProperty])) {\n                            rval[nestProperty] = {};\n                          }\n\n                          nestResult = rval[nestProperty];\n                        }\n\n                        _addValue(nestResult, itemActiveProperty, expandedValue, {\n                          propertyIsArray: true\n                        });\n                      } // recusively process array values\n\n\n                      _iterator3 = _createForOfIteratorHelper(expandedValue);\n                      _context.prev = 101;\n\n                      _iterator3.s();\n\n                    case 103:\n                      if ((_step3 = _iterator3.n()).done) {\n                        _context.next = 201;\n                        break;\n                      }\n\n                      expandedItem = _step3.value;\n                      // compact property and get container type\n                      _itemActiveProperty = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: expandedProperty,\n                        value: expandedItem,\n                        relativeTo: {\n                          vocab: true\n                        },\n                        reverse: insideReverse\n                      }); // if itemActiveProperty is a @nest property, add values to nestResult,\n                      // otherwise rval\n\n                      _nestProperty = activeCtx.mappings.has(_itemActiveProperty) ? activeCtx.mappings.get(_itemActiveProperty)['@nest'] : null;\n                      _nestResult = rval;\n\n                      if (_nestProperty) {\n                        _checkNestProperty(activeCtx, _nestProperty, options);\n\n                        if (!_isObject(rval[_nestProperty])) {\n                          rval[_nestProperty] = {};\n                        }\n\n                        _nestResult = rval[_nestProperty];\n                      }\n\n                      _container5 = _getContextValue(activeCtx, _itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate\n\n                      isGraph = _isGraph(expandedItem);\n                      isList = _isList(expandedItem);\n                      inner = void 0;\n\n                      if (isList) {\n                        inner = expandedItem['@list'];\n                      } else if (isGraph) {\n                        inner = expandedItem['@graph'];\n                      } // recursively compact expanded item\n\n\n                      _context.next = 116;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: _itemActiveProperty,\n                        element: isList || isGraph ? inner : expandedItem,\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 116:\n                      compactedItem = _context.sent;\n\n                      if (!isList) {\n                        _context.next = 126;\n                        break;\n                      }\n\n                      // ensure @list value is an array\n                      if (!_isArray(compactedItem)) {\n                        compactedItem = [compactedItem];\n                      }\n\n                      if (_container5.includes('@list')) {\n                        _context.next = 124;\n                        break;\n                      }\n\n                      // wrap using @list alias\n                      compactedItem = _defineProperty({}, api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@list',\n                        relativeTo: {\n                          vocab: true\n                        }\n                      }), compactedItem); // include @index from expanded @list, if any\n\n                      if ('@index' in expandedItem) {\n                        compactedItem[api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@index',\n                          relativeTo: {\n                            vocab: true\n                          }\n                        })] = expandedItem['@index'];\n                      }\n\n                      _context.next = 126;\n                      break;\n\n                    case 124:\n                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                        valueIsArray: true,\n                        allowDuplicate: true\n                      });\n\n                      return _context.abrupt(\"continue\", 199);\n\n                    case 126:\n                      if (!isGraph) {\n                        _context.next = 130;\n                        break;\n                      }\n\n                      if (_container5.includes('@graph') && (_container5.includes('@id') || _container5.includes('@index') && _isSimpleGraph(expandedItem))) {\n                        // get or create the map object\n                        mapObject = void 0;\n\n                        if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                          mapObject = _nestResult[_itemActiveProperty];\n                        } else {\n                          _nestResult[_itemActiveProperty] = mapObject = {};\n                        } // index on @id or @index or alias of @none\n\n\n                        key = (_container5.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@none',\n                          vocab: true\n                        }); // add compactedItem to map, using value of `@id` or a new blank\n                        // node identifier\n\n                        _addValue(mapObject, key, compactedItem, {\n                          propertyIsArray: !options.compactArrays || _container5.includes('@set')\n                        });\n                      } else if (_container5.includes('@graph') && _isSimpleGraph(expandedItem)) {\n                        // container includes @graph but not @id or @index and value is a\n                        // simple graph object add compact value\n                        // if compactedItem contains multiple values, it is wrapped in\n                        // `@included`\n                        if (_isArray(compactedItem) && compactedItem.length > 1) {\n                          compactedItem = {\n                            '@included': compactedItem\n                          };\n                        }\n\n                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                          propertyIsArray: !options.compactArrays || _container5.includes('@set')\n                        });\n                      } else {\n                        // wrap using @graph alias, remove array if only one item and\n                        // compactArrays not set\n                        if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n                          compactedItem = compactedItem[0];\n                        }\n\n                        compactedItem = _defineProperty({}, api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@graph',\n                          relativeTo: {\n                            vocab: true\n                          }\n                        }), compactedItem); // include @id from expanded graph, if any\n\n                        if ('@id' in expandedItem) {\n                          compactedItem[api.compactIri({\n                            activeCtx: activeCtx,\n                            iri: '@id',\n                            relativeTo: {\n                              vocab: true\n                            }\n                          })] = expandedItem['@id'];\n                        } // include @index from expanded graph, if any\n\n\n                        if ('@index' in expandedItem) {\n                          compactedItem[api.compactIri({\n                            activeCtx: activeCtx,\n                            iri: '@index',\n                            relativeTo: {\n                              vocab: true\n                            }\n                          })] = expandedItem['@index'];\n                        }\n\n                        _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                          propertyIsArray: !options.compactArrays || _container5.includes('@set')\n                        });\n                      }\n\n                      _context.next = 199;\n                      break;\n\n                    case 130:\n                      if (!(_container5.includes('@language') || _container5.includes('@index') || _container5.includes('@id') || _container5.includes('@type'))) {\n                        _context.next = 197;\n                        break;\n                      }\n\n                      // handle language and index maps\n                      // get or create the map object\n                      _mapObject = void 0;\n\n                      if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n                        _mapObject = _nestResult[_itemActiveProperty];\n                      } else {\n                        _nestResult[_itemActiveProperty] = _mapObject = {};\n                      }\n\n                      _key = void 0;\n\n                      if (!_container5.includes('@language')) {\n                        _context.next = 139;\n                        break;\n                      }\n\n                      // if container is a language map, simplify compacted value to\n                      // a simple string\n                      if (_isValue(compactedItem)) {\n                        compactedItem = compactedItem['@value'];\n                      }\n\n                      _key = expandedItem['@language'];\n                      _context.next = 193;\n                      break;\n\n                    case 139:\n                      if (!_container5.includes('@index')) {\n                        _context.next = 167;\n                        break;\n                      }\n\n                      indexKey = _getContextValue(activeCtx, _itemActiveProperty, '@index') || '@index';\n                      containerKey = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: indexKey,\n                        vocab: true\n                      });\n\n                      if (!(indexKey === '@index')) {\n                        _context.next = 147;\n                        break;\n                      }\n\n                      _key = expandedItem['@index'];\n                      delete compactedItem[containerKey];\n                      _context.next = 165;\n                      break;\n\n                    case 147:\n                      others = void 0;\n                      _asArray2 = _asArray(compactedItem[indexKey] || []);\n                      _asArray3 = _toArray(_asArray2);\n                      _key = _asArray3[0];\n                      others = _asArray3.slice(1);\n\n                      if (_isString(_key)) {\n                        _context.next = 156;\n                        break;\n                      }\n\n                      // Will use @none if it isn't a string.\n                      _key = null;\n                      _context.next = 165;\n                      break;\n\n                    case 156:\n                      _context.t1 = others.length;\n                      _context.next = _context.t1 === 0 ? 159 : _context.t1 === 1 ? 161 : 163;\n                      break;\n\n                    case 159:\n                      delete compactedItem[indexKey];\n                      return _context.abrupt(\"break\", 165);\n\n                    case 161:\n                      compactedItem[indexKey] = others[0];\n                      return _context.abrupt(\"break\", 165);\n\n                    case 163:\n                      compactedItem[indexKey] = others;\n                      return _context.abrupt(\"break\", 165);\n\n                    case 165:\n                      _context.next = 193;\n                      break;\n\n                    case 167:\n                      if (!_container5.includes('@id')) {\n                        _context.next = 173;\n                        break;\n                      }\n\n                      idKey = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@id',\n                        vocab: true\n                      });\n                      _key = compactedItem[idKey];\n                      delete compactedItem[idKey];\n                      _context.next = 193;\n                      break;\n\n                    case 173:\n                      if (!_container5.includes('@type')) {\n                        _context.next = 193;\n                        break;\n                      }\n\n                      typeKey = api.compactIri({\n                        activeCtx: activeCtx,\n                        iri: '@type',\n                        vocab: true\n                      });\n                      _types = void 0;\n                      _asArray4 = _asArray(compactedItem[typeKey] || []);\n                      _asArray5 = _toArray(_asArray4);\n                      _key = _asArray5[0];\n                      _types = _asArray5.slice(1);\n                      _context.t2 = _types.length;\n                      _context.next = _context.t2 === 0 ? 183 : _context.t2 === 1 ? 185 : 187;\n                      break;\n\n                    case 183:\n                      delete compactedItem[typeKey];\n                      return _context.abrupt(\"break\", 189);\n\n                    case 185:\n                      compactedItem[typeKey] = _types[0];\n                      return _context.abrupt(\"break\", 189);\n\n                    case 187:\n                      compactedItem[typeKey] = _types;\n                      return _context.abrupt(\"break\", 189);\n\n                    case 189:\n                      if (!(Object.keys(compactedItem).length === 1 && '@id' in expandedItem)) {\n                        _context.next = 193;\n                        break;\n                      }\n\n                      _context.next = 192;\n                      return api.compact({\n                        activeCtx: activeCtx,\n                        activeProperty: _itemActiveProperty,\n                        element: {\n                          '@id': expandedItem['@id']\n                        },\n                        options: options,\n                        compactionMap: compactionMap\n                      });\n\n                    case 192:\n                      compactedItem = _context.sent;\n\n                    case 193:\n                      // if compacting this value which has no key, index on @none\n                      if (!_key) {\n                        _key = api.compactIri({\n                          activeCtx: activeCtx,\n                          iri: '@none',\n                          vocab: true\n                        });\n                      } // add compact value to map object using key from expanded value\n                      // based on the container type\n\n\n                      _addValue(_mapObject, _key, compactedItem, {\n                        propertyIsArray: _container5.includes('@set')\n                      });\n\n                      _context.next = 199;\n                      break;\n\n                    case 197:\n                      // use an array if: compactArrays flag is false,\n                      // @container is @set or @list , value is an empty\n                      // array, or key is @graph\n                      _isArray2 = !options.compactArrays || _container5.includes('@set') || _container5.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value\n\n                      _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n                        propertyIsArray: _isArray2\n                      });\n\n                    case 199:\n                      _context.next = 103;\n                      break;\n\n                    case 201:\n                      _context.next = 206;\n                      break;\n\n                    case 203:\n                      _context.prev = 203;\n                      _context.t3 = _context[\"catch\"](101);\n\n                      _iterator3.e(_context.t3);\n\n                    case 206:\n                      _context.prev = 206;\n\n                      _iterator3.f();\n\n                      return _context.finish(206);\n\n                    case 209:\n                      _context.next = 55;\n                      break;\n\n                    case 211:\n                      _context.next = 216;\n                      break;\n\n                    case 213:\n                      _context.prev = 213;\n                      _context.t4 = _context[\"catch\"](53);\n\n                      _iterator2.e(_context.t4);\n\n                    case 216:\n                      _context.prev = 216;\n\n                      _iterator2.f();\n\n                      return _context.finish(216);\n\n                    case 219:\n                      return _context.abrupt(\"return\", {\n                        v: rval\n                      });\n\n                    case 220:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee, null, [[31, 45, 48, 51], [53, 213, 216, 219], [101, 203, 206, 209]]);\n            })(), \"t0\", 27);\n\n          case 27:\n            _ret = _context2.t0;\n\n            if (!(typeof _ret === \"object\")) {\n              _context2.next = 30;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", _ret.v);\n\n          case 30:\n            return _context2.abrupt(\"return\", element);\n\n          case 31:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\n\n\napi.compactIri = function (_ref3) {\n  var activeCtx = _ref3.activeCtx,\n      iri = _ref3.iri,\n      _ref3$value = _ref3.value,\n      value = _ref3$value === void 0 ? null : _ref3$value,\n      _ref3$relativeTo = _ref3.relativeTo,\n      relativeTo = _ref3$relativeTo === void 0 ? {\n    vocab: false\n  } : _ref3$relativeTo,\n      _ref3$reverse = _ref3.reverse,\n      reverse = _ref3$reverse === void 0 ? false : _ref3$reverse;\n\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  } // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n\n\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  var inverseCtx = activeCtx.getInverse(); // if term is a keyword, it may be compacted to a simple alias\n\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  } // use inverse context to pick a term if iri is relative to vocab\n\n\n  if (relativeTo.vocab && iri in inverseCtx) {\n    var defaultLanguage = activeCtx['@language'] || '@none'; // prefer @index if available in value\n\n    var containers = [];\n\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    } // if value is a preserve object, use its value\n\n\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    } // prefer most specific container including @graph, prefering @set\n    // variations\n\n\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // favor idmap if the graph is has an @id\n\n\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n\n      containers.push('@graph', '@graph@set', '@set'); // allow indexmap if the graph is not indexed\n\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      } // allow idmap if the graph does not have an @id\n\n\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    } // defaults for term selection based on type/language\n\n\n    var typeOrLanguage = '@language';\n    var typeOrLanguageValue = '@null';\n\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n\n      var list = value['@list'];\n\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        var commonLanguage = list.length === 0 ? defaultLanguage : null;\n        var commonType = null;\n\n        for (var i = 0; i < list.length; ++i) {\n          var item = list[i];\n          var itemLanguage = '@none';\n          var itemType = '@none';\n\n          if (_isValue(item)) {\n            if ('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          } // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n\n\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n\n      containers.push('@set');\n    } // do term selection\n\n\n    containers.push('@none'); // an index map can be used to index values using @none, so add as a low\n    // priority\n\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    } // values without type or language can use @language map\n\n\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n\n    if (term !== null) {\n      return term;\n    }\n  } // no term match, use @vocab if available\n\n\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      var vocab = activeCtx['@vocab'];\n\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        var suffix = iri.substr(vocab.length);\n\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  } // no term or @vocab match, check for possible CURIEs\n\n\n  var choice = null; // TODO: make FastCurieMap a class with a method to do this lookup\n\n  var partialMatches = [];\n  var iriMap = activeCtx.fastCurieMap; // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n\n  var maxPartialLength = iri.length - 1;\n\n  for (var _i2 = 0; _i2 < maxPartialLength && iri[_i2] in iriMap; ++_i2) {\n    iriMap = iriMap[iri[_i2]];\n\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  } // check partial matches in reverse order to prefer longest ones first\n\n\n  for (var _i3 = partialMatches.length - 1; _i3 >= 0; --_i3) {\n    var entry = partialMatches[_i3];\n    var terms = entry.terms;\n\n    var _iterator4 = _createForOfIteratorHelper(terms),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _term = _step4.value;\n        // a CURIE is usable if:\n        // 1. it has no mapping, OR\n        // 2. value is null, which means we're not compacting an @value, AND\n        //   the mapping matches the IRI\n        var curie = _term + ':' + iri.substr(entry.iri.length);\n        var isUsableCurie = activeCtx.mappings.get(_term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri); // select curie if it is shorter or the same length but lexicographically\n        // less than the current choice\n\n        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n          choice = curie;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } // return chosen curie\n\n\n  if (choice !== null) {\n    return choice;\n  } // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n\n\n  var _iterator5 = _createForOfIteratorHelper(activeCtx.mappings),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _step5$value = _slicedToArray(_step5.value, 2),\n          _term2 = _step5$value[0],\n          td = _step5$value[1];\n\n      if (td && td._prefix && iri.startsWith(_term2 + ':')) {\n        throw new JsonLdError(\"Absolute IRI \\\"\".concat(iri, \"\\\" confused with prefix \\\"\").concat(_term2, \"\\\".\"), 'jsonld.SyntaxError', {\n          code: 'IRI confused with prefix',\n          context: activeCtx\n        });\n      }\n    } // compact IRI relative to base\n\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  if (!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  } // return IRI as is\n\n\n  return iri;\n};\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\n\n\napi.compactValue = function (_ref4) {\n  var activeCtx = _ref4.activeCtx,\n      activeProperty = _ref4.activeProperty,\n      value = _ref4.value,\n      options = _ref4.options;\n\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    var _type = _getContextValue(activeCtx, activeProperty, '@type');\n\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n\n    var container = _getContextValue(activeCtx, activeProperty, '@container') || []; // whether or not the value has an @index that must be preserved\n\n    var preserveIndex = '@index' in value && !container.includes('@index'); // if there's no @index to preserve ...\n\n    if (!preserveIndex && _type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === _type || value['@language'] === language) {\n        return value['@value'];\n      }\n    } // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n\n\n    var keyCount = Object.keys(value).length;\n    var isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    var hasDefaultLanguage = ('@language' in activeCtx);\n\n    var isValueString = _isString(value['@value']);\n\n    var hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n\n    if (isValueOnlyKey && _type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    var rval = {}; // preserve @index\n\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx: activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    } // alias @value\n\n\n    rval[api.compactIri({\n      activeCtx: activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  } // value is a subject reference\n\n\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n\n  var type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  var compacted = api.compactIri({\n    activeCtx: activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    }\n  }); // compact to scalar\n\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return _defineProperty({}, api.compactIri({\n    activeCtx: activeCtx,\n    iri: '@id',\n    relativeTo: {\n      vocab: true\n    }\n  }), compacted);\n};\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\n\n\napi.removePreserve = function (ctx, input, options) {\n  // recurse through arrays\n  if (_isArray(input)) {\n    var output = [];\n\n    for (var i = 0; i < input.length; ++i) {\n      var result = api.removePreserve(ctx, input[i], options); // drop nulls from arrays\n\n      if (result !== null) {\n        output.push(result);\n      }\n    }\n\n    input = output;\n  } else if (_isObject(input)) {\n    // remove @preserve\n    if ('@preserve' in input) {\n      if (input['@preserve'] === '@null') {\n        return null;\n      }\n\n      return input['@preserve'];\n    } // skip @values\n\n\n    if (_isValue(input)) {\n      return input;\n    } // recurse through @lists\n\n\n    if (_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    } // handle in-memory linked nodes\n\n\n    var idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (input.hasOwnProperty(idAlias)) {\n      var id = input[idAlias];\n\n      if (options.link.hasOwnProperty(id)) {\n        var idx = options.link[id].indexOf(input);\n\n        if (idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        } // prevent circular visitation\n\n\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    } // recurse through properties\n\n\n    var graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    for (var prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if (prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      var _result = api.removePreserve(ctx, input[prop], options);\n\n      var container = _getContextValue(ctx, prop, '@container') || [];\n\n      if (options.compactArrays && _isArray(_result) && _result.length === 1 && container.length === 0 && prop !== graphAlias) {\n        _result = _result[0];\n      }\n\n      input[prop] = _result;\n    }\n  }\n\n  return input;\n};\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\n\n\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  } // preferences for the value of @type or @language\n\n\n  var prefs = []; // determine prefs for @id based on whether or not value compacts to a term\n\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    } // try to compact value to a term\n\n\n    var term = api.compactIri({\n      activeCtx: activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n\n  prefs.push('@none');\n  var containerMap = activeCtx.inverse[iri];\n\n  var _iterator6 = _createForOfIteratorHelper(containers),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var container = _step6.value;\n\n      // if container not available in the map, continue\n      if (!(container in containerMap)) {\n        continue;\n      }\n\n      var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n\n      var _iterator7 = _createForOfIteratorHelper(prefs),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var pref = _step7.value;\n\n          // if type/language option not available in the map, continue\n          if (!(pref in typeOrLanguageValueMap)) {\n            continue;\n          } // select term\n\n\n          return typeOrLanguageValueMap[pref];\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return null;\n}\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\n\n\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld/lib/compact.js"],"names":["JsonLdError","require","_isArray","isArray","_isObject","isObject","_isString","isString","_isUndefined","isUndefined","_isList","isList","_isValue","isValue","_isGraph","isGraph","_isSimpleGraph","isSimpleGraph","_isSubjectReference","isSubjectReference","_expandIri","expandIri","_getContextValue","getContextValue","_isKeyword","isKeyword","_processContext","process","_processingMode","processingMode","_removeBase","removeBase","_addValue","addValue","_asArray","asArray","_compareShortestLeast","compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","propagate","overrideProtected","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","inputCtx","revertToPreviousContext","propertyScopedCtx","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","keys","Object","expandedProperty","expandedValue","compactedValue","map","expandedIri","alias","typeAsSet","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","indexKey","containerKey","others","idKey","typeKey","isPropertyTermScoped","previousContext","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","td","startsWith","code","context","language","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","removePreserve","input","output","result","idAlias","id","idx","graphAlias","prop","bnodesToClear","prefs","apply","containerMap","inverse","typeOrLanguageValueMap","pref"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't @graph or @list\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none', vocab: true});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, vocab: true});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id', vocab: true});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              vocab: true\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none', vocab: true});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@language' in item) {\n              itemLanguage = item['@language'];\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    return _removeBase(activeCtx['@base'], iri);\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type || value['@language'] === language) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri(\n    {activeCtx, iri: value['@id'], relativeTo: {vocab: type === '@vocab'}});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Removes the @preserve keywords as the last step of the compaction\n * algorithm when it is running on framed output.\n *\n * @param ctx the active context used to compact the input.\n * @param input the framed, compacted output.\n * @param options the compaction options used.\n *\n * @return the resulting output.\n */\napi.removePreserve = (ctx, input, options) => {\n  // recurse through arrays\n  if(_isArray(input)) {\n    const output = [];\n    for(let i = 0; i < input.length; ++i) {\n      const result = api.removePreserve(ctx, input[i], options);\n      // drop nulls from arrays\n      if(result !== null) {\n        output.push(result);\n      }\n    }\n    input = output;\n  } else if(_isObject(input)) {\n    // remove @preserve\n    if('@preserve' in input) {\n      if(input['@preserve'] === '@null') {\n        return null;\n      }\n      return input['@preserve'];\n    }\n\n    // skip @values\n    if(_isValue(input)) {\n      return input;\n    }\n\n    // recurse through @lists\n    if(_isList(input)) {\n      input['@list'] = api.removePreserve(ctx, input['@list'], options);\n      return input;\n    }\n\n    // handle in-memory linked nodes\n    const idAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    });\n    if(input.hasOwnProperty(idAlias)) {\n      const id = input[idAlias];\n      if(options.link.hasOwnProperty(id)) {\n        const idx = options.link[id].indexOf(input);\n        if(idx !== -1) {\n          // already visited\n          return options.link[id][idx];\n        }\n        // prevent circular visitation\n        options.link[id].push(input);\n      } else {\n        // prevent circular visitation\n        options.link[id] = [input];\n      }\n    }\n\n    // recurse through properties\n    const graphAlias = api.compactIri({\n      activeCtx: ctx,\n      iri: '@graph',\n      relativeTo: {vocab: true}\n    });\n    for(const prop in input) {\n      // potentially remove the id, if it is an unreference bnode\n      if(prop === idAlias && options.bnodesToClear.includes(input[prop])) {\n        delete input[idAlias];\n        continue;\n      }\n\n      let result = api.removePreserve(ctx, input[prop], options);\n      const container = _getContextValue(ctx, prop, '@container') || [];\n      if(options.compactArrays && _isArray(result) && result.length === 1 &&\n        container.length === 0 && prop !== graphAlias) {\n        result = result[0];\n      }\n      input[prop] = result;\n    }\n  }\n  return input;\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"]},"metadata":{},"sourceType":"script"}