{"ast":null,"code":"/*!\n * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n/* Core API */\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar api = {};\nmodule.exports = api;\n/* API Constants */\n\nvar constants = require('./constants');\n\nObject.assign(api, constants); // TODO: support `ProofChain`\n\nvar ProofSet = require('./ProofSet');\n\nvar VerificationError = require('./VerificationError');\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object|string} document - The document to be signed, either a string URL\n *  (resolved to an object via the given `documentLoader`) or a plain object\n *  (JSON-LD document).\n *\n * @param {LinkedDataSignature} suite - The linked data signature cryptographic\n *   suite, containing private key material, with which to sign the document.\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\n\n\napi.sign = /*#__PURE__*/function () {\n  var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(document) {\n    var _ref,\n        suite,\n        purpose,\n        documentLoader,\n        expansionMap,\n        compactProof,\n        url,\n        err,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, suite = _ref.suite, purpose = _ref.purpose, documentLoader = _ref.documentLoader, expansionMap = _ref.expansionMap, compactProof = _ref.compactProof;\n            _context.prev = 1;\n            _context.next = 4;\n            return new ProofSet().add(document, {\n              suite: suite,\n              purpose: purpose,\n              documentLoader: documentLoader,\n              expansionMap: expansionMap,\n              compactProof: compactProof\n            });\n\n          case 4:\n            return _context.abrupt(\"return\", _context.sent);\n\n          case 7:\n            _context.prev = 7;\n            _context.t0 = _context[\"catch\"](1);\n\n            if (!(!documentLoader && _context.t0.name === 'jsonld.InvalidUrl')) {\n              _context.next = 14;\n              break;\n            }\n\n            url = _context.t0.details.url;\n            err = new Error(\"A URL \\\"\".concat(url, \"\\\" could not be fetched; you need to pass \") + '\"documentLoader\" or resolve the URL before calling \"sign\".');\n            err.cause = _context.t0;\n            throw err;\n\n          case 14:\n            throw _context.t0;\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[1, 7]]);\n  }));\n\n  function sign(_x) {\n    return _sign.apply(this, arguments);\n  }\n\n  return sign;\n}();\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object|string} document - The document with one or more proofs to be\n *   verified, either a string URL (resolved to an object via the given\n *   `documentLoader`) or a plain object (JSON-LD document).\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @return {Promise<{verified: boolean, results: Array, error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\n\n\napi.verify = /*#__PURE__*/function () {\n  var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(document) {\n    var _ref2,\n        suite,\n        purpose,\n        documentLoader,\n        expansionMap,\n        compactProof,\n        result,\n        error,\n        url,\n        urlError,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2 = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, suite = _ref2.suite, purpose = _ref2.purpose, documentLoader = _ref2.documentLoader, expansionMap = _ref2.expansionMap, compactProof = _ref2.compactProof;\n            _context2.next = 3;\n            return new ProofSet().verify(document, {\n              suite: suite,\n              purpose: purpose,\n              documentLoader: documentLoader,\n              expansionMap: expansionMap,\n              compactProof: compactProof\n            });\n\n          case 3:\n            result = _context2.sent;\n            error = result.error;\n\n            if (error) {\n              if (!documentLoader && error.name === 'jsonld.InvalidUrl') {\n                url = error.details.url;\n                urlError = new Error(\"A URL \\\"\".concat(url, \"\\\" could not be fetched; you need to pass \") + '\"documentLoader\" or resolve the URL before calling \"verify\".');\n                result.error = new VerificationError(urlError);\n              } else {\n                result.error = new VerificationError(error);\n              }\n            }\n\n            return _context2.abrupt(\"return\", result);\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  function verify(_x2) {\n    return _verify.apply(this, arguments);\n  }\n\n  return verify;\n}(); // expose suite classes\n\n\napi.suites = require('./suites').suites; // expose ProofPurpose classes to enable extensions\n\napi.purposes = require('./purposes').purposes; // expose LDKeyPair classes\n\nObject.assign(api, require('crypto-ld')); // expose document loader helpers\n\nObject.assign(api, require('./documentLoader'));","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld-signatures/lib/jsonld-signatures.js"],"names":["api","module","exports","constants","require","Object","assign","ProofSet","VerificationError","sign","document","suite","purpose","documentLoader","expansionMap","compactProof","add","name","url","details","err","Error","cause","verify","result","error","urlError","suites","purposes"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n/* Core API */\nconst api = {};\nmodule.exports = api;\n\n/* API Constants */\nconst constants = require('./constants');\nObject.assign(api, constants);\n\n// TODO: support `ProofChain`\nconst ProofSet = require('./ProofSet');\nconst VerificationError = require('./VerificationError');\n\n/**\n * Cryptographically signs the provided document by adding a `proof` section,\n * based on the provided suite and proof purpose.\n *\n * @param {object|string} document - The document to be signed, either a string URL\n *  (resolved to an object via the given `documentLoader`) or a plain object\n *  (JSON-LD document).\n *\n * @param {LinkedDataSignature} suite - The linked data signature cryptographic\n *   suite, containing private key material, with which to sign the document.\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @returns {Promise<object>} Resolves with signed document.\n */\napi.sign = async function sign(document, {\n  suite, purpose, documentLoader, expansionMap, compactProof} = {}) {\n  try {\n    return await new ProofSet().add(\n      document, {suite, purpose, documentLoader, expansionMap, compactProof});\n  } catch(e) {\n    if(!documentLoader && e.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = e;\n      const err = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"sign\".');\n      err.cause = e;\n      throw err;\n    }\n    throw e;\n  }\n};\n\n/**\n * Verifies the linked data signature on the provided document.\n *\n * @param {object|string} document - The document with one or more proofs to be\n *   verified, either a string URL (resolved to an object via the given\n *   `documentLoader`) or a plain object (JSON-LD document).\n *\n * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n *   Acceptable signature suite instances for verifying the proof(s).\n *\n * @param {ProofPurpose} purpose - A proof purpose instance that will\n *   match proofs to be verified and ensure they were created according to\n *   the appropriate purpose.\n *\n * Advanced optional parameters and overrides:\n *\n * @param {function} [documentLoader]  - A custom document loader,\n *   `Promise<RemoteDocument> documentLoader(url)`.\n * @param {function} [expansionMap] - A custom expansion map that is\n *   passed to the JSON-LD processor; by default a function that will throw\n *   an error when unmapped properties are detected in the input, use `false`\n *   to turn this off and allow unmapped properties to be dropped or use a\n *   custom function.\n * @param {boolean} [compactProof=true] - Indicates that this method cannot\n *   assume that the incoming document has defined all proof terms in the\n *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n *   This means that this method must compact any found proofs to this\n *   context for internal and extension processing; this is the default\n *   behavior. To override this behavior and optimize away this step because\n *   the caller knows that the input document's JSON-LD `@context` defines\n *   the proof terms in the same way, set this flag to `false`.\n *\n * @return {Promise<{verified: boolean, results: Array, error: VerificationError}>}\n *   resolves with an object with a `verified` boolean property that is `true`\n *   if at least one proof matching the given purpose and suite verifies and\n *   `false` otherwise; a `results` property with an array of detailed results;\n *   if `false` an `error` property will be present, with `error.errors`\n *   containing all of the errors that occurred during the verification process.\n */\napi.verify = async function verify(document, {\n  suite, purpose, documentLoader, expansionMap, compactProof} = {}) {\n  const result = await new ProofSet().verify(\n    document, {suite, purpose, documentLoader, expansionMap, compactProof});\n  const {error} = result;\n  if(error) {\n    if(!documentLoader && error.name === 'jsonld.InvalidUrl') {\n      const {details: {url}} = error;\n      const urlError = new Error(\n        `A URL \"${url}\" could not be fetched; you need to pass ` +\n        '\"documentLoader\" or resolve the URL before calling \"verify\".');\n      result.error = new VerificationError(urlError);\n    } else {\n      result.error = new VerificationError(error);\n    }\n  }\n  return result;\n};\n\n// expose suite classes\napi.suites = require('./suites').suites;\n\n// expose ProofPurpose classes to enable extensions\napi.purposes = require('./purposes').purposes;\n\n// expose LDKeyPair classes\nObject.assign(api, require('crypto-ld'));\n\n// expose document loader helpers\nObject.assign(api, require('./documentLoader'));\n"]},"metadata":{},"sourceType":"script"}