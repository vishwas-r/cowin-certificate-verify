{"ast":null,"code":"/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar forge = require('node-forge');\n\nvar base58 = forge.util.binary.base58;\n\nvar LDKeyPair = /*#__PURE__*/function () {\n  /**\n   *  Note: Actual key material\n   * (like `publicKeyBase58` for Ed25519 or\n   * `publicKeyPem` for RSA) is handled in the subclass.\n   * An LDKeyPair can encrypt private key material.\n   * @classdesc The Abstract Base Class on which KeyPairs are based.\n   * @example\n   * // LDKeyPair is an Abstract Class and should only\n   * // be used as a base class for other KeyPairs.\n   * @param {KeyPairOptions} [options={}] -\n   * See [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} [options.passphrase=null] - For encrypting the private key.\n   * @param {string} options.id - The Key id.\n   * @param {string} options.controller - DID of the person/entity controlling\n   *   this key.\n   * @param {string} [options.owner]  - DID or URI of owner. DEPRECATED, use\n   *  `controller` instead.\n   */\n  function LDKeyPair() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LDKeyPair);\n\n    this.passphrase = options.passphrase || null;\n    this.id = options.id;\n    this.controller = options.controller;\n    this.owner = options.owner; // this.type is set in subclass constructor\n    // this.publicKey* and this.privateKey* is handled in sub-classes\n  }\n  /**\n   * @abstract\n   * @interface\n   * @readonly\n   *  Returns the public key.\n   * @throws  If not implemented by the subclass.\n   *\n   * @returns {string} A public key.\n   */\n\n\n  _createClass(LDKeyPair, [{\n    key: \"publicKey\",\n    get: function get() {\n      throw new Error('Abstract method, must be implemented in subclass.');\n    }\n    /**\n     * @abstract\n     * @interface\n     * @readonly\n     *  Returns the private key.\n     * @throws If not implemented by the subclass.\n     *\n     * @returns {string} A private key.\n     */\n\n  }, {\n    key: \"privateKey\",\n    get: function get() {\n      throw new Error('Abstract method, must be implemented in subclass.');\n    }\n    /**\n     * Generates an LdKeyPair using SerializedLdKey options.\n     * @param {SerializedLdKey} options - Options for generating the KeyPair.\n     * @example\n     * > const options = {\n     *    type: 'RsaVerificationKey2018',\n     *    passphrase: 'Test1234'\n     *  };\n     * > const keyPair = await LDKeyPair.generate(options);\n     *\n     * @returns {Promise<LDKeyPair>} An LDKeyPair.\n     * @throws Unsupported Key Type.\n     * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n     */\n\n  }, {\n    key: \"publicNode\",\n    value:\n    /**\n     * Contains the encryption type & public key for the KeyPair\n     * and other information that json-ld Signatures can use to form a proof.\n     * @param {Object} [options={}] - Needs either a controller or owner.\n     * @param {string} [options.controller=this.controller]  - DID of the\n     * person/entity controlling this key pair.\n     * @param {string} [options.owner=this.owner] - DID of key owner.\n     * Deprecated term, use `controller`.\n     * @example\n     * > ldKeyPair.publicNode();\n     * {id: 'test-keypair-id', owner: 'did:uuid:example'}\n     *\n     * @returns {Object} A public node with\n     * information used in verification methods by signatures.\n     */\n    function publicNode() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$controller = _ref.controller,\n          controller = _ref$controller === void 0 ? this.controller : _ref$controller,\n          _ref$owner = _ref.owner,\n          owner = _ref$owner === void 0 ? this.owner : _ref$owner;\n\n      var publicNode = {\n        id: this.id,\n        type: this.type\n      };\n\n      if (controller) {\n        publicNode.controller = controller;\n      }\n\n      if (owner) {\n        publicNode.owner = owner;\n      }\n\n      this.addEncodedPublicKey(publicNode); // Subclass-specific\n\n      return publicNode;\n    } // publicKeyPem, publicKeyJwk, publicKeyHex, publicKeyBase64, publicKeyBase58\n\n    /**\n     * Exports the publicNode with an encrypted private key attached.\n     * @example\n     * > const withPrivateKey = await edKeyPair.export();\n     *\n     * @returns {KeyPairOptions} A public node with encrypted private key.\n     * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n     */\n\n  }, {\n    key: \"export\",\n    value: function () {\n      var _export2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var keyNode;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                keyNode = this.publicNode();\n                return _context.abrupt(\"return\", this.addEncryptedPrivateKey(keyNode));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _export() {\n        return _export2.apply(this, arguments);\n      }\n\n      return _export;\n    }()\n  }], [{\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(options) {\n        var Ed25519KeyPair, RSAKeyPair;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = options.type;\n                _context2.next = _context2.t0 === 'Ed25519VerificationKey2018' ? 3 : _context2.t0 === 'RsaVerificationKey2018' ? 5 : 7;\n                break;\n\n              case 3:\n                Ed25519KeyPair = require('./Ed25519KeyPair');\n                return _context2.abrupt(\"return\", Ed25519KeyPair.generate(options));\n\n              case 5:\n                RSAKeyPair = require('./RSAKeyPair');\n                return _context2.abrupt(\"return\", RSAKeyPair.generate(options));\n\n              case 7:\n                throw new Error(\"Unsupported Key Type: \".concat(options.type));\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function generate(_x) {\n        return _generate.apply(this, arguments);\n      }\n\n      return generate;\n    }()\n    /**\n     * Generates a KeyPair from some options.\n     * @param {SerializedLdKey} options  - Will generate a key pair\n     * in multiple different formats.\n     * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n     * @example\n     * > const options = {\n     *    type: 'Ed25519VerificationKey2018',\n     *    passphrase: 'Test1234'\n     *   };\n     * > const edKeyPair = await LDKeyPair.from(options);\n     *\n     * @returns {Promise<LDKeyPair>} A LDKeyPair.\n     * @throws Unsupported Key Type.\n     */\n\n  }, {\n    key: \"from\",\n    value: function () {\n      var _from = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {\n        var Ed25519KeyPair, RSAKeyPair;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = options.type;\n                _context3.next = _context3.t0 === 'Ed25519VerificationKey2018' ? 3 : _context3.t0 === 'RsaVerificationKey2018' ? 5 : 7;\n                break;\n\n              case 3:\n                Ed25519KeyPair = require('./Ed25519KeyPair');\n                return _context3.abrupt(\"return\", Ed25519KeyPair.from(options));\n\n              case 5:\n                RSAKeyPair = require('./RSAKeyPair');\n                return _context3.abrupt(\"return\", RSAKeyPair.from(options));\n\n              case 7:\n                throw new Error(\"Unsupported Key Type: \".concat(options.type));\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function from(_x2) {\n        return _from.apply(this, arguments);\n      }\n\n      return from;\n    }()\n    /**\n     * Creates an instance of LDKeyPair from a key fingerprint.\n     * Note: Only key types that use their full public key in the fingerprint\n     * are supported (so, currently, only 'ed25519').\n     *\n     * @param {string} fingerprint\n     * @returns {LDKeyPair}\n     * @throws Unsupported Fingerprint Type.\n     */\n\n  }, {\n    key: \"fromFingerprint\",\n    value: function fromFingerprint(_ref2) {\n      var fingerprint = _ref2.fingerprint;\n      // skip leading `z` that indicates base58 encoding\n      var buffer = base58.decode(fingerprint.substr(1)); // buffer is: 0xed 0x01 <public key bytes>\n\n      if (buffer[0] === 0xed && buffer[1] === 0x01) {\n        var Ed25519KeyPair = require('./Ed25519KeyPair');\n\n        return new Ed25519KeyPair({\n          publicKeyBase58: base58.encode(buffer.slice(2))\n        });\n      }\n\n      throw new Error(\"Unsupported Fingerprint Type: \".concat(fingerprint));\n    }\n    /**\n     * Generates a\n     * [pdkdf2]{@link https://en.wikipedia.org/wiki/PBKDF2} key.\n     * @param {string} password - The password for the key.\n     * @param {string} salt - Noise used to randomize the key.\n     * @param {number} iterations - The number of times to run the algorithm.\n     * @param {number} keySize - The byte length of the key.\n     * @example\n     * > const key = await LdKeyPair.pbkdf2('Test1234', salt, 10, 32);\n     *\n     * @returns {Promise<Object>} A promise that resolves to a pdkdf2 key.\n     * @see https://github.com/digitalbazaar/forge#pkcs5\n     */\n\n  }, {\n    key: \"pbkdf2\",\n    value: function () {\n      var _pbkdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(password, salt, iterations, keySize) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  forge.pkcs5.pbkdf2(password, salt, iterations, keySize, function (err, key) {\n                    return err ? reject(err) : resolve(key);\n                  });\n                }));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function pbkdf2(_x3, _x4, _x5, _x6) {\n        return _pbkdf.apply(this, arguments);\n      }\n\n      return pbkdf2;\n    }()\n  }]);\n\n  return LDKeyPair;\n}();\n\nmodule.exports = LDKeyPair;","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/crypto-ld/lib/LDKeyPair.js"],"names":["forge","require","base58","util","binary","LDKeyPair","options","passphrase","id","controller","owner","Error","publicNode","type","addEncodedPublicKey","keyNode","addEncryptedPrivateKey","Ed25519KeyPair","generate","RSAKeyPair","from","fingerprint","buffer","decode","substr","publicKeyBase58","encode","slice","password","salt","iterations","keySize","Promise","resolve","reject","pkcs5","pbkdf2","err","key","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst forge = require('node-forge');\nconst {util: {binary: {base58}}} = forge;\n\nclass LDKeyPair {\n  /**\n   *  Note: Actual key material\n   * (like `publicKeyBase58` for Ed25519 or\n   * `publicKeyPem` for RSA) is handled in the subclass.\n   * An LDKeyPair can encrypt private key material.\n   * @classdesc The Abstract Base Class on which KeyPairs are based.\n   * @example\n   * // LDKeyPair is an Abstract Class and should only\n   * // be used as a base class for other KeyPairs.\n   * @param {KeyPairOptions} [options={}] -\n   * See [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} [options.passphrase=null] - For encrypting the private key.\n   * @param {string} options.id - The Key id.\n   * @param {string} options.controller - DID of the person/entity controlling\n   *   this key.\n   * @param {string} [options.owner]  - DID or URI of owner. DEPRECATED, use\n   *  `controller` instead.\n   */\n  constructor(options = {}) {\n    this.passphrase = options.passphrase || null;\n    this.id = options.id;\n    this.controller = options.controller;\n    this.owner = options.owner;\n    // this.type is set in subclass constructor\n    // this.publicKey* and this.privateKey* is handled in sub-classes\n  }\n  /**\n   * @abstract\n   * @interface\n   * @readonly\n   *  Returns the public key.\n   * @throws  If not implemented by the subclass.\n   *\n   * @returns {string} A public key.\n   */\n  get publicKey() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n  /**\n   * @abstract\n   * @interface\n   * @readonly\n   *  Returns the private key.\n   * @throws If not implemented by the subclass.\n   *\n   * @returns {string} A private key.\n   */\n  get privateKey() {\n    throw new Error('Abstract method, must be implemented in subclass.');\n  }\n  /**\n   * Generates an LdKeyPair using SerializedLdKey options.\n   * @param {SerializedLdKey} options - Options for generating the KeyPair.\n   * @example\n   * > const options = {\n   *    type: 'RsaVerificationKey2018',\n   *    passphrase: 'Test1234'\n   *  };\n   * > const keyPair = await LDKeyPair.generate(options);\n   *\n   * @returns {Promise<LDKeyPair>} An LDKeyPair.\n   * @throws Unsupported Key Type.\n   * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n   */\n  static async generate(options) {\n    switch(options.type) {\n      case 'Ed25519VerificationKey2018':\n        const Ed25519KeyPair = require('./Ed25519KeyPair');\n        return Ed25519KeyPair.generate(options);\n\n      case 'RsaVerificationKey2018':\n        const RSAKeyPair = require('./RSAKeyPair');\n        return RSAKeyPair.generate(options);\n\n      default:\n        throw new Error(`Unsupported Key Type: ${options.type}`);\n    }\n  }\n\n  /**\n   * Generates a KeyPair from some options.\n   * @param {SerializedLdKey} options  - Will generate a key pair\n   * in multiple different formats.\n   * @see [SerializedLdKey]{@link ./index.md#SerializedLdKey}\n   * @example\n   * > const options = {\n   *    type: 'Ed25519VerificationKey2018',\n   *    passphrase: 'Test1234'\n   *   };\n   * > const edKeyPair = await LDKeyPair.from(options);\n   *\n   * @returns {Promise<LDKeyPair>} A LDKeyPair.\n   * @throws Unsupported Key Type.\n   */\n  static async from(options) {\n    switch(options.type) {\n      case 'Ed25519VerificationKey2018':\n        const Ed25519KeyPair = require('./Ed25519KeyPair');\n        return Ed25519KeyPair.from(options);\n\n      case 'RsaVerificationKey2018':\n        const RSAKeyPair = require('./RSAKeyPair');\n        return RSAKeyPair.from(options);\n\n      default:\n        throw new Error(`Unsupported Key Type: ${options.type}`);\n    }\n  }\n\n  /**\n   * Creates an instance of LDKeyPair from a key fingerprint.\n   * Note: Only key types that use their full public key in the fingerprint\n   * are supported (so, currently, only 'ed25519').\n   *\n   * @param {string} fingerprint\n   * @returns {LDKeyPair}\n   * @throws Unsupported Fingerprint Type.\n   */\n  static fromFingerprint({fingerprint}) {\n    // skip leading `z` that indicates base58 encoding\n    const buffer = base58.decode(fingerprint.substr(1));\n\n    // buffer is: 0xed 0x01 <public key bytes>\n    if(buffer[0] === 0xed && buffer[1] === 0x01) {\n      const Ed25519KeyPair = require('./Ed25519KeyPair');\n      return new Ed25519KeyPair({\n        publicKeyBase58: base58.encode(buffer.slice(2))\n      });\n    }\n\n    throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);\n  }\n\n  /**\n   * Generates a\n   * [pdkdf2]{@link https://en.wikipedia.org/wiki/PBKDF2} key.\n   * @param {string} password - The password for the key.\n   * @param {string} salt - Noise used to randomize the key.\n   * @param {number} iterations - The number of times to run the algorithm.\n   * @param {number} keySize - The byte length of the key.\n   * @example\n   * > const key = await LdKeyPair.pbkdf2('Test1234', salt, 10, 32);\n   *\n   * @returns {Promise<Object>} A promise that resolves to a pdkdf2 key.\n   * @see https://github.com/digitalbazaar/forge#pkcs5\n   */\n  static async pbkdf2(password, salt, iterations, keySize) {\n    return new Promise((resolve, reject) => {\n      forge.pkcs5.pbkdf2(password, salt, iterations, keySize, (err, key) =>\n        err ? reject(err) : resolve(key));\n    });\n  }\n\n  /**\n   * Contains the encryption type & public key for the KeyPair\n   * and other information that json-ld Signatures can use to form a proof.\n   * @param {Object} [options={}] - Needs either a controller or owner.\n   * @param {string} [options.controller=this.controller]  - DID of the\n   * person/entity controlling this key pair.\n   * @param {string} [options.owner=this.owner] - DID of key owner.\n   * Deprecated term, use `controller`.\n   * @example\n   * > ldKeyPair.publicNode();\n   * {id: 'test-keypair-id', owner: 'did:uuid:example'}\n   *\n   * @returns {Object} A public node with\n   * information used in verification methods by signatures.\n   */\n  publicNode({controller = this.controller, owner = this.owner} = {}) {\n    const publicNode = {\n      id: this.id,\n      type: this.type,\n    };\n    if(controller) {\n      publicNode.controller = controller;\n    }\n    if(owner) {\n      publicNode.owner = owner;\n    }\n    this.addEncodedPublicKey(publicNode); // Subclass-specific\n    return publicNode;\n  }\n\n  // publicKeyPem, publicKeyJwk, publicKeyHex, publicKeyBase64, publicKeyBase58\n  /**\n   * Exports the publicNode with an encrypted private key attached.\n   * @example\n   * > const withPrivateKey = await edKeyPair.export();\n   *\n   * @returns {KeyPairOptions} A public node with encrypted private key.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  async export() {\n    const keyNode = this.publicNode();\n    return this.addEncryptedPrivateKey(keyNode); // Subclass-specific\n  }\n}\n\nmodule.exports = LDKeyPair;\n"]},"metadata":{},"sourceType":"script"}