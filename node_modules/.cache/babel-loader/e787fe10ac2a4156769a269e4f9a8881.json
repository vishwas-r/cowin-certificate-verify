{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _objectSpread = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar constants = require('./constants');\n\nvar jsonld = require('jsonld');\n\nvar _require = require('./documentLoader'),\n    extendContextLoader = _require.extendContextLoader,\n    strictDocumentLoader = _require.strictDocumentLoader;\n\nvar _require2 = require('serialize-error'),\n    serializeError = _require2.serializeError;\n\nvar strictExpansionMap = require('./expansionMap');\n\nvar PublicKeyProofPurpose = require('./purposes/PublicKeyProofPurpose');\n\nmodule.exports = /*#__PURE__*/function () {\n  function ProofSet() {\n    _classCallCheck(this, ProofSet);\n  }\n\n  _createClass(ProofSet, [{\n    key: \"add\",\n    value:\n    /**\n     * Adds a Linked Data proof to a document. If the document contains other\n     * proofs, the new proof will be appended to the existing set of proofs.\n     *\n     * Important note: This method assumes that the term `proof` in the given\n     * document has the same definition as the `https://w3id.org/security/v2`\n     * JSON-LD @context.\n     *\n     * @param document {object|string} Object to be signed, either a string URL\n     *   (resolved via the given `documentLoader`) or a plain object (JSON-LD\n     *   document).\n     * @param options {object} Options hashmap.\n     *\n     * A `suite` option is required:\n     *\n     * @param options.suite {LinkedDataSignature} a signature suite instance\n     *   that will create the proof.\n     *\n     * A `purpose` option is required:\n     *\n     * @param options.purpose {ProofPurpose} a proof purpose instance that will\n     *   augment the proof with information describing its intended purpose.\n     *\n     * Advanced optional parameters and overrides:\n     *\n     * @param [documentLoader] {function} a custom document loader,\n     *   `Promise<RemoteDocument> documentLoader(url)`.\n     * @param [expansionMap] {function} A custom expansion map that is\n     *   passed to the JSON-LD processor; by default a function that will throw\n     *   an error when unmapped properties are detected in the input, use `false`\n     *   to turn this off and allow unmapped properties to be dropped or use a\n     *   custom function.\n     * @param [compactProof] {boolean} `true` instructs this call to compact\n     *   the resulting proof to the same JSON-LD `@context` as the input\n     *   document; this is the default behavior. Setting this flag to `false` can\n     *   be used as an optimization to prevent an unnecessary compaction when the\n     *   caller knows that all used proof terms have the same definition in the\n     *   document's `@context` as the `constants.SECURITY_CONTEXT_URL` `@context`.\n     *\n     * @return {Promise<object>} resolves with the signed document, with\n     *   the signature in the top-level `proof` property.\n     */\n    function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(document) {\n        var _ref,\n            suite,\n            purpose,\n            documentLoader,\n            expansionMap,\n            _ref$compactProof,\n            compactProof,\n            input,\n            proofProperty,\n            proof,\n            expandedProof,\n            _yield$_getTypeInfo,\n            types,\n            alias,\n            ctx,\n            _compactProof,\n            key,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, suite = _ref.suite, purpose = _ref.purpose, documentLoader = _ref.documentLoader, expansionMap = _ref.expansionMap, _ref$compactProof = _ref.compactProof, compactProof = _ref$compactProof === void 0 ? true : _ref$compactProof;\n\n                if (suite) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new TypeError('\"options.suite\" is required.');\n\n              case 3:\n                if (purpose) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new TypeError('\"options.purpose\" is required.');\n\n              case 5:\n                if (!suite.legacy) {\n                  _context.next = 8;\n                  break;\n                }\n\n                if (purpose instanceof PublicKeyProofPurpose) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw new TypeError(\"The \\\"\".concat(suite.type, \"\\\" suite requires \\\"options.purpose\\\" to be \") + 'an instance of \"PublicKeyProofPurpose\".');\n\n              case 8:\n                if (documentLoader) {\n                  documentLoader = extendContextLoader(documentLoader);\n                } else {\n                  documentLoader = strictDocumentLoader;\n                }\n\n                if (expansionMap !== false) {\n                  expansionMap = strictExpansionMap;\n                }\n\n                if (!(typeof document === 'string')) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _context.next = 13;\n                return documentLoader(document);\n\n              case 13:\n                document = _context.sent;\n\n              case 14:\n                if (!compactProof) {\n                  _context.next = 20;\n                  break;\n                }\n\n                _context.next = 17;\n                return jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap,\n                  compactToRelative: false\n                });\n\n              case 17:\n                input = _context.sent;\n                _context.next = 21;\n                break;\n\n              case 20:\n                // TODO: optimize to modify document in place to maximize optimization\n                // shallow copy document to allow removal of existing proofs\n                input = _objectSpread({}, document);\n\n              case 21:\n                // save but exclude any existing proof(s)\n                proofProperty = suite.legacy ? 'signature' : 'proof'; //const existingProofs = input[proofProperty];\n\n                delete input[proofProperty]; // create the new proof (suites MUST output a proof using the security-v2\n                // `@context`)\n\n                _context.next = 25;\n                return suite.createProof({\n                  document: input,\n                  purpose: purpose,\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap,\n                  compactProof: compactProof\n                });\n\n              case 25:\n                proof = _context.sent;\n\n                if (!compactProof) {\n                  _context.next = 44;\n                  break;\n                }\n\n                // compact proof to match document's context\n                if (suite.legacy) {\n                  expandedProof = _defineProperty({}, constants.SECURITY_SIGNATURE_URL, proof);\n                } else {\n                  expandedProof = _defineProperty({}, constants.SECURITY_PROOF_URL, {\n                    '@graph': proof\n                  });\n                } // account for type-scoped `proof` definition by getting document types\n\n\n                _context.next = 30;\n                return _getTypeInfo({\n                  document: document,\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap\n                });\n\n              case 30:\n                _yield$_getTypeInfo = _context.sent;\n                types = _yield$_getTypeInfo.types;\n                alias = _yield$_getTypeInfo.alias;\n                expandedProof['@type'] = types;\n                ctx = jsonld.getValues(document, '@context');\n                _context.next = 37;\n                return jsonld.compact(expandedProof, ctx, {\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap,\n                  compactToRelative: false\n                });\n\n              case 37:\n                _compactProof = _context.sent;\n                delete _compactProof[alias];\n                delete _compactProof['@context']; // add proof to document\n\n                key = Object.keys(_compactProof)[0];\n                jsonld.addValue(document, key, _compactProof[key]);\n                _context.next = 46;\n                break;\n\n              case 44:\n                // in-place restore any existing proofs\n\n                /*if(existingProofs) {\n                  document[proofProperty] = existingProofs;\n                }*/\n                // add new proof\n                delete proof['@context'];\n                jsonld.addValue(document, proofProperty, proof);\n\n              case 46:\n                return _context.abrupt(\"return\", document);\n\n              case 47:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function add(_x) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n     * Verifies Linked Data proof(s) on a document. The proofs to be verified\n     * must match the given proof purpose.\n     *\n     * Important note: This method assumes that the term `proof` in the given\n     * document has the same definition as the `https://w3id.org/security/v2`\n     * JSON-LD @context.\n     *\n     * @param {object|string} document - Object with one or more proofs to be\n     *   verified, either a string URL (resolved to an object via the given\n     *   `documentLoader`) or a plain object (JSON-LD document).\n     *\n     * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n     *   Acceptable signature suite instances for verifying the proof(s).\n     *\n     * @param {ProofPurpose} purpose - A proof purpose instance that will\n     *   match proofs to be verified and ensure they were created according to\n     *   the appropriate purpose.\n     *\n     * Advanced optional parameters and overrides:\n     *\n     * @param {function} [documentLoader]  a custom document loader,\n     *   `Promise<RemoteDocument> documentLoader(url)`.\n     * @param {function} [expansionMap] - A custom expansion map that is\n     *   passed to the JSON-LD processor; by default a function that will throw\n     *   an error when unmapped properties are detected in the input, use `false`\n     *   to turn this off and allow unmapped properties to be dropped or use a\n     *   custom function.\n     * @param {boolean} [compactProof=true] - Indicates that this method cannot\n     *   assume that the incoming document has defined all proof terms in the\n     *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n     *   This means that this method must compact any found proofs to this\n     *   context for internal and extension processing; this is the default\n     *   behavior. To override this behavior and optimize away this step because\n     *   the caller knows that the input document's JSON-LD `@context` defines\n     *   the proof terms in the same way, set this flag to `false`.\n     *\n     * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n     *   with an object with a `verified`boolean property that is `true` if at\n     *   least one proof matching the given purpose and suite verifies and `false`\n     *   otherwise; a `results` property with an array of detailed results;\n     *   if `false` an `error` property will be present.\n     */\n\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(document) {\n        var _ref2,\n            suite,\n            purpose,\n            documentLoader,\n            expansionMap,\n            _ref2$compactProof,\n            compactProof,\n            suites,\n            legacy,\n            _yield$_getProofs,\n            proofSet,\n            doc,\n            results,\n            verified,\n            _ref3,\n            errors,\n            result,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref2 = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, suite = _ref2.suite, purpose = _ref2.purpose, documentLoader = _ref2.documentLoader, expansionMap = _ref2.expansionMap, _ref2$compactProof = _ref2.compactProof, compactProof = _ref2$compactProof === void 0 ? true : _ref2$compactProof;\n\n                if (suite) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new TypeError('\"options.suite\" is required.');\n\n              case 3:\n                if (purpose) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new TypeError('\"options.purpose\" is required.');\n\n              case 5:\n                suites = Array.isArray(suite) ? suite : [suite];\n\n                if (!(suites.length === 0)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new TypeError('At least one suite is required.');\n\n              case 8:\n                legacy = suites.some(function (s) {\n                  return s.legacy;\n                });\n\n                if (!legacy) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                if (!suites.some(function (s) {\n                  return !s.legacy;\n                })) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                throw new Error('Legacy suites may not be combined with current suites.');\n\n              case 14:\n                if (purpose instanceof PublicKeyProofPurpose) {\n                  _context2.next = 16;\n                  break;\n                }\n\n                throw new TypeError('\"options.purpose\" must be an instance of \"PublicKeyProofPurpose\"' + 'to use a legacy suite.');\n\n              case 16:\n                if (documentLoader) {\n                  documentLoader = extendContextLoader(documentLoader);\n                } else {\n                  documentLoader = strictDocumentLoader;\n                }\n\n                if (expansionMap !== false) {\n                  expansionMap = strictExpansionMap;\n                }\n\n                _context2.prev = 18;\n\n                if (!(typeof document === 'string')) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                _context2.next = 22;\n                return documentLoader(document);\n\n              case 22:\n                document = _context2.sent;\n                _context2.next = 26;\n                break;\n\n              case 25:\n                // TODO: consider in-place editing to optimize when `compactProof`\n                // is `false`\n                // shallow copy to allow for removal of proof set prior to canonize\n                document = _objectSpread({}, document);\n\n              case 26:\n                _context2.next = 28;\n                return _getProofs({\n                  document: document,\n                  legacy: legacy,\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap,\n                  compactProof: compactProof\n                });\n\n              case 28:\n                _yield$_getProofs = _context2.sent;\n                proofSet = _yield$_getProofs.proofSet;\n                doc = _yield$_getProofs.document;\n                document = doc; // verify proofs\n\n                _context2.next = 34;\n                return _verify({\n                  document: document,\n                  suites: suites,\n                  proofSet: proofSet,\n                  purpose: purpose,\n                  documentLoader: documentLoader,\n                  expansionMap: expansionMap,\n                  compactProof: compactProof\n                });\n\n              case 34:\n                results = _context2.sent;\n\n                if (!(results.length === 0)) {\n                  _context2.next = 37;\n                  break;\n                }\n\n                throw new Error('Could not verify any proofs; no proofs matched the required ' + 'suite and purpose.');\n\n              case 37:\n                // combine results\n                verified = results.some(function (r) {\n                  return r.verified;\n                });\n\n                if (verified) {\n                  _context2.next = 43;\n                  break;\n                }\n\n                errors = (_ref3 = []).concat.apply(_ref3, _toConsumableArray(results.filter(function (r) {\n                  return r.error;\n                }).map(function (r) {\n                  return r.error;\n                })));\n                result = {\n                  verified: verified,\n                  results: results\n                };\n\n                if (errors.length > 0) {\n                  result.error = errors;\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 43:\n                return _context2.abrupt(\"return\", {\n                  verified: verified,\n                  results: results\n                });\n\n              case 46:\n                _context2.prev = 46;\n                _context2.t0 = _context2[\"catch\"](18);\n\n                _addToJSON(_context2.t0);\n\n                return _context2.abrupt(\"return\", {\n                  verified: false,\n                  error: _context2.t0\n                });\n\n              case 50:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[18, 46]]);\n      }));\n\n      function verify(_x2) {\n        return _verify2.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }]);\n\n  return ProofSet;\n}();\n\nfunction _getProofs(_x3) {\n  return _getProofs2.apply(this, arguments);\n}\n\nfunction _getProofs2() {\n  _getProofs2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4) {\n    var document, legacy, documentLoader, expansionMap, compactProof, proofProperty, proofSet;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            document = _ref4.document, legacy = _ref4.legacy, documentLoader = _ref4.documentLoader, expansionMap = _ref4.expansionMap, compactProof = _ref4.compactProof;\n            // handle document preprocessing to find proofs\n            proofProperty = legacy ? 'signature' : 'proof';\n\n            if (!compactProof) {\n              _context3.next = 6;\n              break;\n            }\n\n            _context3.next = 5;\n            return jsonld.compact(document, constants.SECURITY_CONTEXT_URL, {\n              documentLoader: documentLoader,\n              expansionMap: expansionMap,\n              compactToRelative: false\n            });\n\n          case 5:\n            document = _context3.sent;\n\n          case 6:\n            proofSet = jsonld.getValues(document, proofProperty);\n            delete document[proofProperty];\n\n            if (!(proofSet.length === 0)) {\n              _context3.next = 10;\n              break;\n            }\n\n            throw new Error('No matching proofs found in the given document.');\n\n          case 10:\n            // TODO: consider in-place editing to optimize\n            // shallow copy proofs and add SECURITY_CONTEXT_URL\n            proofSet = proofSet.map(function (proof) {\n              return _objectSpread({\n                '@context': constants.SECURITY_CONTEXT_URL\n              }, proof);\n            });\n            return _context3.abrupt(\"return\", {\n              proofSet: proofSet,\n              document: document\n            });\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _getProofs2.apply(this, arguments);\n}\n\nfunction _verify(_x4) {\n  return _verify3.apply(this, arguments);\n} // add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\n\n\nfunction _verify3() {\n  _verify3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(_ref5) {\n    var document, suites, proofSet, purpose, documentLoader, expansionMap, compactProof, result, matches;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            document = _ref5.document, suites = _ref5.suites, proofSet = _ref5.proofSet, purpose = _ref5.purpose, documentLoader = _ref5.documentLoader, expansionMap = _ref5.expansionMap, compactProof = _ref5.compactProof;\n            _context5.next = 3;\n            return Promise.all(proofSet.map(function (proof) {\n              return purpose.match(proof, {\n                document: document,\n                documentLoader: documentLoader,\n                expansionMap: expansionMap\n              });\n            }));\n\n          case 3:\n            result = _context5.sent;\n            matches = proofSet.filter(function (value, index) {\n              return result[index];\n            });\n\n            if (!(matches.length === 0)) {\n              _context5.next = 7;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", []);\n\n          case 7:\n            _context5.next = 9;\n            return Promise.all(matches.map( /*#__PURE__*/function () {\n              var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(proof) {\n                var _iterator, _step, s;\n\n                return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                  while (1) {\n                    switch (_context4.prev = _context4.next) {\n                      case 0:\n                        _iterator = _createForOfIteratorHelper(suites);\n                        _context4.prev = 1;\n\n                        _iterator.s();\n\n                      case 3:\n                        if ((_step = _iterator.n()).done) {\n                          _context4.next = 11;\n                          break;\n                        }\n\n                        s = _step.value;\n                        _context4.next = 7;\n                        return s.matchProof({\n                          proof: proof,\n                          document: document,\n                          documentLoader: documentLoader,\n                          expansionMap: expansionMap\n                        });\n\n                      case 7:\n                        if (!_context4.sent) {\n                          _context4.next = 9;\n                          break;\n                        }\n\n                        return _context4.abrupt(\"return\", s.verifyProof({\n                          proof: proof,\n                          document: document,\n                          purpose: purpose,\n                          documentLoader: documentLoader,\n                          expansionMap: expansionMap,\n                          compactProof: compactProof\n                        }).catch(function (error) {\n                          return {\n                            verified: false,\n                            error: error\n                          };\n                        }));\n\n                      case 9:\n                        _context4.next = 3;\n                        break;\n\n                      case 11:\n                        _context4.next = 16;\n                        break;\n\n                      case 13:\n                        _context4.prev = 13;\n                        _context4.t0 = _context4[\"catch\"](1);\n\n                        _iterator.e(_context4.t0);\n\n                      case 16:\n                        _context4.prev = 16;\n\n                        _iterator.f();\n\n                        return _context4.finish(16);\n\n                      case 19:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }\n                }, _callee4, null, [[1, 13, 16, 19]]);\n              }));\n\n              return function (_x6) {\n                return _ref7.apply(this, arguments);\n              };\n            }()));\n\n          case 9:\n            return _context5.abrupt(\"return\", _context5.sent.map(function (r, i) {\n              if (!r) {\n                return null;\n              }\n\n              if (r.error) {\n                _addToJSON(r.error);\n              }\n\n              return _objectSpread({\n                proof: matches[i]\n              }, r);\n            }).filter(function (r) {\n              return r;\n            }));\n\n          case 10:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _verify3.apply(this, arguments);\n}\n\nfunction _addToJSON(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function value() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nfunction _getTypeInfo(_x5) {\n  return _getTypeInfo2.apply(this, arguments);\n}\n\nfunction _getTypeInfo2() {\n  _getTypeInfo2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref6) {\n    var document, documentLoader, expansionMap, ctx, compacted, alias, toExpand, expanded;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            document = _ref6.document, documentLoader = _ref6.documentLoader, expansionMap = _ref6.expansionMap;\n            // determine `@type` alias, if any\n            ctx = jsonld.getValues(document, '@context');\n            _context6.next = 4;\n            return jsonld.compact({\n              '@type': '_:b0'\n            }, ctx, {\n              documentLoader: documentLoader,\n              expansionMap: expansionMap\n            });\n\n          case 4:\n            compacted = _context6.sent;\n            delete compacted['@context'];\n            alias = Object.keys(compacted)[0]; // optimize: expand only `@type` and `type` values\n\n            toExpand = {\n              '@context': ctx\n            };\n            toExpand['@type'] = jsonld.getValues(document, '@type').concat(jsonld.getValues(document, alias));\n            _context6.next = 11;\n            return jsonld.expand(toExpand, {\n              documentLoader: documentLoader,\n              expansionMap: expansionMap\n            });\n\n          case 11:\n            _context6.t0 = _context6.sent[0];\n\n            if (_context6.t0) {\n              _context6.next = 14;\n              break;\n            }\n\n            _context6.t0 = {};\n\n          case 14:\n            expanded = _context6.t0;\n            return _context6.abrupt(\"return\", {\n              types: jsonld.getValues(expanded, '@type'),\n              alias: alias\n            });\n\n          case 16:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n  return _getTypeInfo2.apply(this, arguments);\n}","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld-signatures/lib/ProofSet.js"],"names":["constants","require","jsonld","extendContextLoader","strictDocumentLoader","serializeError","strictExpansionMap","PublicKeyProofPurpose","module","exports","document","suite","purpose","documentLoader","expansionMap","compactProof","TypeError","legacy","type","compact","SECURITY_CONTEXT_URL","compactToRelative","input","proofProperty","createProof","proof","expandedProof","SECURITY_SIGNATURE_URL","SECURITY_PROOF_URL","_getTypeInfo","types","alias","ctx","getValues","key","Object","keys","addValue","suites","Array","isArray","length","some","s","Error","_getProofs","proofSet","doc","_verify","results","verified","r","errors","concat","filter","error","map","result","_addToJSON","Promise","all","match","matches","value","index","matchProof","verifyProof","catch","i","defineProperty","configurable","writable","compacted","toExpand","expand","expanded"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst constants = require('./constants');\nconst jsonld = require('jsonld');\nconst {extendContextLoader, strictDocumentLoader} = require('./documentLoader');\nconst {serializeError} = require('serialize-error');\nconst strictExpansionMap = require('./expansionMap');\nconst PublicKeyProofPurpose = require('./purposes/PublicKeyProofPurpose');\n\nmodule.exports = class ProofSet {\n  /**\n   * Adds a Linked Data proof to a document. If the document contains other\n   * proofs, the new proof will be appended to the existing set of proofs.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param document {object|string} Object to be signed, either a string URL\n   *   (resolved via the given `documentLoader`) or a plain object (JSON-LD\n   *   document).\n   * @param options {object} Options hashmap.\n   *\n   * A `suite` option is required:\n   *\n   * @param options.suite {LinkedDataSignature} a signature suite instance\n   *   that will create the proof.\n   *\n   * A `purpose` option is required:\n   *\n   * @param options.purpose {ProofPurpose} a proof purpose instance that will\n   *   augment the proof with information describing its intended purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param [documentLoader] {function} a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param [expansionMap] {function} A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param [compactProof] {boolean} `true` instructs this call to compact\n   *   the resulting proof to the same JSON-LD `@context` as the input\n   *   document; this is the default behavior. Setting this flag to `false` can\n   *   be used as an optimization to prevent an unnecessary compaction when the\n   *   caller knows that all used proof terms have the same definition in the\n   *   document's `@context` as the `constants.SECURITY_CONTEXT_URL` `@context`.\n   *\n   * @return {Promise<object>} resolves with the signed document, with\n   *   the signature in the top-level `proof` property.\n   */\n  async add(document, {\n    suite, purpose, documentLoader, expansionMap,\n    compactProof = true} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n\n    if(suite.legacy) {\n      if(!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError(\n          `The \"${suite.type}\" suite requires \"options.purpose\" to be ` +\n          'an instance of \"PublicKeyProofPurpose\".');\n      }\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    if(typeof document === 'string') {\n      // fetch document\n      document = await documentLoader(document);\n    }\n\n    // preprocess document to prepare to remove existing proofs\n    let input;\n    if(compactProof) {\n      // cannot assume security context terms, so do full compaction\n      input = await jsonld.compact(\n        document, constants.SECURITY_CONTEXT_URL,\n        {documentLoader, expansionMap, compactToRelative: false});\n    } else {\n      // TODO: optimize to modify document in place to maximize optimization\n\n      // shallow copy document to allow removal of existing proofs\n      input = {...document};\n    }\n\n    // save but exclude any existing proof(s)\n    const proofProperty = suite.legacy ? 'signature' : 'proof';\n    //const existingProofs = input[proofProperty];\n    delete input[proofProperty];\n\n    // create the new proof (suites MUST output a proof using the security-v2\n    // `@context`)\n    const proof = await suite.createProof({\n      document: input, purpose, documentLoader,\n      expansionMap, compactProof});\n\n    if(compactProof) {\n      // compact proof to match document's context\n      let expandedProof;\n      if(suite.legacy) {\n        expandedProof = {\n          [constants.SECURITY_SIGNATURE_URL]: proof\n        };\n      } else {\n        expandedProof = {\n          [constants.SECURITY_PROOF_URL]: {'@graph': proof}\n        };\n      }\n      // account for type-scoped `proof` definition by getting document types\n      const {types, alias} = await _getTypeInfo(\n        {document, documentLoader, expansionMap});\n      expandedProof['@type'] = types;\n      const ctx = jsonld.getValues(document, '@context');\n      const compactProof = await jsonld.compact(\n        expandedProof, ctx,\n        {documentLoader, expansionMap, compactToRelative: false});\n      delete compactProof[alias];\n      delete compactProof['@context'];\n\n      // add proof to document\n      const key = Object.keys(compactProof)[0];\n      jsonld.addValue(document, key, compactProof[key]);\n    } else {\n      // in-place restore any existing proofs\n      /*if(existingProofs) {\n        document[proofProperty] = existingProofs;\n      }*/\n      // add new proof\n      delete proof['@context'];\n      jsonld.addValue(document, proofProperty, proof);\n    }\n\n    return document;\n  }\n\n  /**\n   * Verifies Linked Data proof(s) on a document. The proofs to be verified\n   * must match the given proof purpose.\n   *\n   * Important note: This method assumes that the term `proof` in the given\n   * document has the same definition as the `https://w3id.org/security/v2`\n   * JSON-LD @context.\n   *\n   * @param {object|string} document - Object with one or more proofs to be\n   *   verified, either a string URL (resolved to an object via the given\n   *   `documentLoader`) or a plain object (JSON-LD document).\n   *\n   * @param {LinkedDataSignature|LinkedDataSignature[]} suite -\n   *   Acceptable signature suite instances for verifying the proof(s).\n   *\n   * @param {ProofPurpose} purpose - A proof purpose instance that will\n   *   match proofs to be verified and ensure they were created according to\n   *   the appropriate purpose.\n   *\n   * Advanced optional parameters and overrides:\n   *\n   * @param {function} [documentLoader]  a custom document loader,\n   *   `Promise<RemoteDocument> documentLoader(url)`.\n   * @param {function} [expansionMap] - A custom expansion map that is\n   *   passed to the JSON-LD processor; by default a function that will throw\n   *   an error when unmapped properties are detected in the input, use `false`\n   *   to turn this off and allow unmapped properties to be dropped or use a\n   *   custom function.\n   * @param {boolean} [compactProof=true] - Indicates that this method cannot\n   *   assume that the incoming document has defined all proof terms in the\n   *   same way as the `constants.SECURITY_CONTEXT_URL` JSON-LD `@context`.\n   *   This means that this method must compact any found proofs to this\n   *   context for internal and extension processing; this is the default\n   *   behavior. To override this behavior and optimize away this step because\n   *   the caller knows that the input document's JSON-LD `@context` defines\n   *   the proof terms in the same way, set this flag to `false`.\n   *\n   * @return {Promise<{verified: boolean, results: Array, error: *}>} resolves\n   *   with an object with a `verified`boolean property that is `true` if at\n   *   least one proof matching the given purpose and suite verifies and `false`\n   *   otherwise; a `results` property with an array of detailed results;\n   *   if `false` an `error` property will be present.\n   */\n  async verify(document, {\n    suite, purpose, documentLoader, expansionMap,\n    compactProof = true} = {}) {\n    if(!suite) {\n      throw new TypeError('\"options.suite\" is required.');\n    }\n    if(!purpose) {\n      throw new TypeError('\"options.purpose\" is required.');\n    }\n    const suites = Array.isArray(suite) ? suite : [suite];\n    if(suites.length === 0) {\n      throw new TypeError('At least one suite is required.');\n    }\n\n    const legacy = suites.some(s => s.legacy);\n    if(legacy) {\n      if(suites.some(s => !s.legacy)) {\n        throw new Error(\n          'Legacy suites may not be combined with current suites.');\n      } else if(!(purpose instanceof PublicKeyProofPurpose)) {\n        throw new TypeError(\n          '\"options.purpose\" must be an instance of \"PublicKeyProofPurpose\"' +\n          'to use a legacy suite.');\n      }\n    }\n\n    if(documentLoader) {\n      documentLoader = extendContextLoader(documentLoader);\n    } else {\n      documentLoader = strictDocumentLoader;\n    }\n    if(expansionMap !== false) {\n      expansionMap = strictExpansionMap;\n    }\n\n    try {\n      if(typeof document === 'string') {\n        // fetch document\n        document = await documentLoader(document);\n      } else {\n        // TODO: consider in-place editing to optimize when `compactProof`\n        // is `false`\n\n        // shallow copy to allow for removal of proof set prior to canonize\n        document = {...document};\n      }\n\n      // get proofs from document\n      const {proofSet, document: doc} = await _getProofs({\n        document, legacy, documentLoader, expansionMap, compactProof});\n      document = doc;\n\n      // verify proofs\n      const results = await _verify({\n        document, suites, proofSet,\n        purpose, documentLoader, expansionMap, compactProof});\n      if(results.length === 0) {\n        throw new Error(\n          'Could not verify any proofs; no proofs matched the required ' +\n          'suite and purpose.');\n      }\n\n      // combine results\n      const verified = results.some(r => r.verified);\n      if(!verified) {\n        const errors = [].concat(\n          ...results.filter(r => r.error).map(r => r.error));\n        const result = {verified, results};\n        if(errors.length > 0) {\n          result.error = errors;\n        }\n        return result;\n      }\n      return {verified, results};\n    } catch(error) {\n      _addToJSON(error);\n      return {verified: false, error};\n    }\n  }\n};\n\nasync function _getProofs({\n  document, legacy, documentLoader, expansionMap, compactProof}) {\n  // handle document preprocessing to find proofs\n  const proofProperty = legacy ? 'signature' : 'proof';\n  let proofSet;\n  if(compactProof) {\n    // if we must compact the proof(s) then we must first compact the input\n    // document to find the proof(s)\n    document = await jsonld.compact(\n      document, constants.SECURITY_CONTEXT_URL,\n      {documentLoader, expansionMap, compactToRelative: false});\n  }\n  proofSet = jsonld.getValues(document, proofProperty);\n  delete document[proofProperty];\n\n  if(proofSet.length === 0) {\n    // no possible matches\n    throw new Error('No matching proofs found in the given document.');\n  }\n\n  // TODO: consider in-place editing to optimize\n\n  // shallow copy proofs and add SECURITY_CONTEXT_URL\n  proofSet = proofSet.map(proof => ({\n    '@context': constants.SECURITY_CONTEXT_URL,\n    ...proof\n  }));\n\n  return {proofSet, document};\n}\n\nasync function _verify({\n  document, suites, proofSet, purpose,\n  documentLoader, expansionMap, compactProof}) {\n  // filter out matching proofs\n  const result = await Promise.all(proofSet.map(proof =>\n    purpose.match(proof, {document, documentLoader, expansionMap})));\n  const matches = proofSet.filter((value, index) => result[index]);\n  if(matches.length === 0) {\n    // no matches, nothing to verify\n    return [];\n  }\n\n  // verify each matching proof\n  return (await Promise.all(matches.map(async proof => {\n    for(const s of suites) {\n      if(await s.matchProof({proof, document, documentLoader, expansionMap})) {\n        return s.verifyProof({\n          proof, document, purpose, documentLoader, expansionMap,\n          compactProof}).catch(error => ({verified: false, error}));\n      }\n    }\n  }))).map((r, i) => {\n    if(!r) {\n      return null;\n    }\n    if(r.error) {\n      _addToJSON(r.error);\n    }\n    return {proof: matches[i], ...r};\n  }).filter(r => r);\n}\n\n// add a `toJSON` method to an error which allows for errors in validation\n// reports to be serialized properly by `JSON.stringify`.\nfunction _addToJSON(error) {\n  Object.defineProperty(error, 'toJSON', {\n    value: function() {\n      return serializeError(this);\n    },\n    configurable: true,\n    writable: true\n  });\n}\n\nasync function _getTypeInfo({document, documentLoader, expansionMap}) {\n  // determine `@type` alias, if any\n  const ctx = jsonld.getValues(document, '@context');\n  const compacted = await jsonld.compact(\n    {'@type': '_:b0'}, ctx, {documentLoader, expansionMap});\n  delete compacted['@context'];\n  const alias = Object.keys(compacted)[0];\n\n  // optimize: expand only `@type` and `type` values\n  const toExpand = {'@context': ctx};\n  toExpand['@type'] = jsonld.getValues(document, '@type')\n    .concat(jsonld.getValues(document, alias));\n  const expanded = (await jsonld.expand(\n    toExpand, {documentLoader, expansionMap}))[0] || {};\n  return {types: jsonld.getValues(expanded, '@type'), alias};\n}\n"]},"metadata":{},"sourceType":"script"}