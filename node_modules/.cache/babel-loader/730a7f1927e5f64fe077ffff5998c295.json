{"ast":null,"code":"/**\n * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar util = require('./util');\n\nmodule.exports = /*#__PURE__*/function () {\n  function AsyncAlgorithm() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$maxCallStackDept = _ref.maxCallStackDepth,\n        maxCallStackDepth = _ref$maxCallStackDept === void 0 ? 500 : _ref$maxCallStackDept,\n        _ref$maxTotalCallStac = _ref.maxTotalCallStackDepth,\n        maxTotalCallStackDepth = _ref$maxTotalCallStac === void 0 ? 0xFFFFFFFF : _ref$maxTotalCallStac,\n        _ref$timeSlice = _ref.timeSlice,\n        timeSlice = _ref$timeSlice === void 0 ? 10 : _ref$timeSlice;\n\n    _classCallCheck(this, AsyncAlgorithm);\n\n    this.schedule = {};\n    this.schedule.MAX_DEPTH = maxCallStackDepth;\n    this.schedule.MAX_TOTAL_DEPTH = maxTotalCallStackDepth;\n    this.schedule.depth = 0;\n    this.schedule.totalDepth = 0;\n    this.schedule.timeSlice = timeSlice;\n  } // do some work in a time slice, but in serial\n\n\n  _createClass(AsyncAlgorithm, [{\n    key: \"doWork\",\n    value: function doWork(fn, callback) {\n      var schedule = this.schedule;\n\n      if (schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {\n        return callback(new Error('Maximum total call stack depth exceeded; canonicalization aborting.'));\n      }\n\n      (function work() {\n        if (schedule.depth === schedule.MAX_DEPTH) {\n          // stack too deep, run on next tick\n          schedule.depth = 0;\n          schedule.running = false;\n          return util.nextTick(work);\n        } // if not yet running, force run\n\n\n        var now = Date.now();\n\n        if (!schedule.running) {\n          schedule.start = Date.now();\n          schedule.deadline = schedule.start + schedule.timeSlice;\n        } // TODO: should also include an estimate of expectedWorkTime\n\n\n        if (now < schedule.deadline) {\n          schedule.running = true;\n          schedule.depth++;\n          schedule.totalDepth++;\n          return fn(function (err, result) {\n            schedule.depth--;\n            schedule.totalDepth--;\n            callback(err, result);\n          });\n        } // not enough time left in this slice, run after letting browser\n        // do some other things\n\n\n        schedule.depth = 0;\n        schedule.running = false;\n        util.setImmediate(work);\n      })();\n    } // asynchronously loop\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(iterable, fn, callback) {\n      var self = this;\n\n      var _iterator2;\n\n      var idx = 0;\n      var length;\n\n      if (Array.isArray(iterable)) {\n        length = iterable.length;\n\n        _iterator2 = function iterator() {\n          if (idx === length) {\n            return false;\n          }\n\n          _iterator2.value = iterable[idx++];\n          _iterator2.key = idx;\n          return true;\n        };\n      } else {\n        var keys = Object.keys(iterable);\n        length = keys.length;\n\n        _iterator2 = function _iterator() {\n          if (idx === length) {\n            return false;\n          }\n\n          _iterator2.key = keys[idx++];\n          _iterator2.value = iterable[_iterator2.key];\n          return true;\n        };\n      }\n\n      (function iterate(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (_iterator2()) {\n          return self.doWork(function () {\n            return fn(_iterator2.value, _iterator2.key, iterate);\n          });\n        }\n\n        callback();\n      })();\n    } // asynchronous waterfall\n\n  }, {\n    key: \"waterfall\",\n    value: function waterfall(fns, callback) {\n      var self = this;\n      self.forEach(fns, function (fn, idx, callback) {\n        return self.doWork(fn, callback);\n      }, callback);\n    } // asynchronous while\n\n  }, {\n    key: \"whilst\",\n    value: function whilst(condition, fn, callback) {\n      var self = this;\n\n      (function loop(err) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!condition()) {\n          return callback();\n        }\n\n        self.doWork(fn, loop);\n      })();\n    }\n  }]);\n\n  return AsyncAlgorithm;\n}();","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/rdf-canonize/lib/AsyncAlgorithm.js"],"names":["util","require","module","exports","maxCallStackDepth","maxTotalCallStackDepth","timeSlice","schedule","MAX_DEPTH","MAX_TOTAL_DEPTH","depth","totalDepth","fn","callback","Error","work","running","nextTick","now","Date","start","deadline","err","result","setImmediate","iterable","self","iterator","idx","length","Array","isArray","value","key","keys","Object","iterate","doWork","fns","forEach","condition","loop"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2016-2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst util = require('./util');\n\nmodule.exports = class AsyncAlgorithm {\n  constructor({\n    maxCallStackDepth = 500,\n    maxTotalCallStackDepth = 0xFFFFFFFF,\n    // milliseconds\n    timeSlice = 10\n  } = {}) {\n    this.schedule = {};\n    this.schedule.MAX_DEPTH = maxCallStackDepth;\n    this.schedule.MAX_TOTAL_DEPTH = maxTotalCallStackDepth;\n    this.schedule.depth = 0;\n    this.schedule.totalDepth = 0;\n    this.schedule.timeSlice = timeSlice;\n  }\n\n  // do some work in a time slice, but in serial\n  doWork(fn, callback) {\n    const schedule = this.schedule;\n\n    if(schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {\n      return callback(new Error(\n        'Maximum total call stack depth exceeded; canonicalization aborting.'));\n    }\n\n    (function work() {\n      if(schedule.depth === schedule.MAX_DEPTH) {\n        // stack too deep, run on next tick\n        schedule.depth = 0;\n        schedule.running = false;\n        return util.nextTick(work);\n      }\n\n      // if not yet running, force run\n      const now = Date.now();\n      if(!schedule.running) {\n        schedule.start = Date.now();\n        schedule.deadline = schedule.start + schedule.timeSlice;\n      }\n\n      // TODO: should also include an estimate of expectedWorkTime\n      if(now < schedule.deadline) {\n        schedule.running = true;\n        schedule.depth++;\n        schedule.totalDepth++;\n        return fn((err, result) => {\n          schedule.depth--;\n          schedule.totalDepth--;\n          callback(err, result);\n        });\n      }\n\n      // not enough time left in this slice, run after letting browser\n      // do some other things\n      schedule.depth = 0;\n      schedule.running = false;\n      util.setImmediate(work);\n    })();\n  }\n\n  // asynchronously loop\n  forEach(iterable, fn, callback) {\n    const self = this;\n    let iterator;\n    let idx = 0;\n    let length;\n    if(Array.isArray(iterable)) {\n      length = iterable.length;\n      iterator = () => {\n        if(idx === length) {\n          return false;\n        }\n        iterator.value = iterable[idx++];\n        iterator.key = idx;\n        return true;\n      };\n    } else {\n      const keys = Object.keys(iterable);\n      length = keys.length;\n      iterator = () => {\n        if(idx === length) {\n          return false;\n        }\n        iterator.key = keys[idx++];\n        iterator.value = iterable[iterator.key];\n        return true;\n      };\n    }\n\n    (function iterate(err) {\n      if(err) {\n        return callback(err);\n      }\n      if(iterator()) {\n        return self.doWork(() => fn(iterator.value, iterator.key, iterate));\n      }\n      callback();\n    })();\n  }\n\n  // asynchronous waterfall\n  waterfall(fns, callback) {\n    const self = this;\n    self.forEach(\n      fns, (fn, idx, callback) => self.doWork(fn, callback), callback);\n  }\n\n  // asynchronous while\n  whilst(condition, fn, callback) {\n    const self = this;\n    (function loop(err) {\n      if(err) {\n        return callback(err);\n      }\n      if(!condition()) {\n        return callback();\n      }\n      self.doWork(fn, loop);\n    })();\n  }\n};\n"]},"metadata":{},"sourceType":"script"}