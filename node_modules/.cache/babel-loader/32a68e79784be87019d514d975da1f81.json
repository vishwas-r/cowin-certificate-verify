{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nmodule.exports = /*#__PURE__*/function () {\n  function LinkedDataProof() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        type = _ref.type;\n\n    _classCallCheck(this, LinkedDataProof);\n\n    if (typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n\n    this.type = type;\n  }\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n\n\n  _createClass(LinkedDataProof, [{\n    key: \"createProof\",\n    value: function () {\n      var _createProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref2) {\n        var document, purpose, documentLoader, expansionMap, compactProof;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                document = _ref2.document, purpose = _ref2.purpose, documentLoader = _ref2.documentLoader, expansionMap = _ref2.expansionMap, compactProof = _ref2.compactProof;\n                throw new Error('\"createProof\" must be implemented in a derived class.');\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function createProof(_x) {\n        return _createProof.apply(this, arguments);\n      }\n\n      return createProof;\n    }()\n    /**\n     * @param proof {object} the proof to be verified.\n     * @param document {object} the document the proof applies to.\n     * @param purpose {ProofPurpose}\n     * @param documentLoader {function}\n     * @param expansionMap {function}\n     *\n     * @returns {Promise<{object}>} Resolves with the verification result.\n     */\n\n  }, {\n    key: \"verifyProof\",\n    value: function () {\n      var _verifyProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n        var proof, document, purpose, documentLoader, expansionMap;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                proof = _ref3.proof, document = _ref3.document, purpose = _ref3.purpose, documentLoader = _ref3.documentLoader, expansionMap = _ref3.expansionMap;\n                throw new Error('\"verifyProof\" must be implemented in a derived class.');\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function verifyProof(_x2) {\n        return _verifyProof.apply(this, arguments);\n      }\n\n      return verifyProof;\n    }()\n    /**\n     * @param proof {object} the proof to be matched.\n     * @param document {object} the document the proof applies to.\n     * @param purpose {ProofPurpose}\n     * @param documentLoader {function}\n     * @param expansionMap {function}\n     *\n     * @returns {Promise<{boolean}>} Resolves with the verification result.\n     */\n\n  }, {\n    key: \"matchProof\",\n    value: function () {\n      var _matchProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref4) {\n        var proof, document, purpose, documentLoader, expansionMap;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                proof = _ref4.proof, document = _ref4.document, purpose = _ref4.purpose, documentLoader = _ref4.documentLoader, expansionMap = _ref4.expansionMap;\n                return _context3.abrupt(\"return\", proof.type === this.type);\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function matchProof(_x3) {\n        return _matchProof.apply(this, arguments);\n      }\n\n      return matchProof;\n    }()\n  }]);\n\n  return LinkedDataProof;\n}();","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js"],"names":["module","exports","type","TypeError","document","purpose","documentLoader","expansionMap","compactProof","Error","proof"],"mappings":"AAAA;AACA;AACA;AACA;;;;;;;;;;AAEAA,MAAM,CAACC,OAAP;AACE,6BAAyB;AAAA,mFAAJ,EAAI;AAAA,QAAZC,IAAY,QAAZA,IAAY;;AAAA;;AACvB,QAAG,OAAOA,IAAP,KAAgB,QAAnB,EAA6B;AAC3B,YAAM,IAAIC,SAAJ,CAAc,uCAAd,CAAN;AACD;;AACD,SAAKD,IAAL,GAAYA,IAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAhBA;AAAA;AAAA;AAAA,kFAiBE;AAAA;AAAA;AAAA;AAAA;AAAA;AACGE,gBAAAA,QADH,SACGA,QADH,EACaC,OADb,SACaA,OADb,EACsBC,cADtB,SACsBA,cADtB,EACsCC,YADtC,SACsCA,YADtC,EACoDC,YADpD,SACoDA,YADpD;AAAA,sBAEQ,IAAIC,KAAJ,CAAU,uDAAV,CAFR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAjBF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAsBE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9BA;AAAA;AAAA;AAAA,kFA+BE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAmBC,gBAAAA,KAAnB,SAAmBA,KAAnB,EAA0BN,QAA1B,SAA0BA,QAA1B,EAAoCC,OAApC,SAAoCA,OAApC,EAA6CC,cAA7C,SAA6CA,cAA7C,EAA6DC,YAA7D,SAA6DA,YAA7D;AAAA,sBACQ,IAAIE,KAAJ,CAAU,uDAAV,CADR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA/BF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAmCE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3CA;AAAA;AAAA;AAAA,iFA4CE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAkBC,gBAAAA,KAAlB,SAAkBA,KAAlB,EAAyBN,QAAzB,SAAyBA,QAAzB,EAAmCC,OAAnC,SAAmCA,OAAnC,EAA4CC,cAA5C,SAA4CA,cAA5C,EAA4DC,YAA5D,SAA4DA,YAA5D;AAAA,kDACSG,KAAK,CAACR,IAAN,KAAe,KAAKA,IAD7B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OA5CF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class LinkedDataProof {\n  constructor({type} = {}) {\n    if(typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof(\n    {document, purpose, documentLoader, expansionMap, compactProof}) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, purpose, documentLoader, expansionMap}) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param proof {object} the proof to be matched.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    return proof.type === this.type;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}