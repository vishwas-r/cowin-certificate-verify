{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require('./context'),\n    isKeyword = _require.isKeyword;\n\nvar graphTypes = require('./graphTypes');\n\nvar types = require('./types');\n\nvar util = require('./util');\n\nvar JsonLdError = require('./JsonLdError');\n\nvar api = {};\nmodule.exports = api;\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\n\napi.createMergedNodeMap = function (input, options) {\n  options = options || {}; // produce a map of all subjects and name each bnode\n\n  var issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  var graphs = {\n    '@default': {}\n  };\n  api.createNodeMap(input, graphs, '@default', issuer); // add all non-default graphs to default graph\n\n  return api.mergeNodeMaps(graphs);\n};\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\n\n\napi.createNodeMap = function (input, graphs, graph, issuer, name, list) {\n  // recurse through array\n  if (types.isArray(input)) {\n    var _iterator = _createForOfIteratorHelper(input),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var node = _step.value;\n        api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return;\n  } // add non-object to list\n\n\n  if (!types.isObject(input)) {\n    if (list) {\n      list.push(input);\n    }\n\n    return;\n  } // add values to list\n\n\n  if (graphTypes.isValue(input)) {\n    if ('@type' in input) {\n      var type = input['@type']; // rename @type blank node\n\n      if (type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n\n    if (list) {\n      list.push(input);\n    }\n\n    return;\n  } else if (list && graphTypes.isList(input)) {\n    var _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({\n      '@list': _list\n    });\n    return;\n  } // Note: At this point, input must be a subject.\n  // spec requires @type to be named first, so assign names early\n\n\n  if ('@type' in input) {\n    var _types = input['@type'];\n\n    var _iterator2 = _createForOfIteratorHelper(_types),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _type = _step2.value;\n\n        if (_type.indexOf('_:') === 0) {\n          issuer.getId(_type);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } // get name for subject\n\n\n  if (types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];\n  } // add subject reference to list\n\n\n  if (list) {\n    list.push({\n      '@id': name\n    });\n  } // create new subject or merge into existing one\n\n\n  var subjects = graphs[graph];\n  var subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  var properties = Object.keys(input).sort();\n\n  var _iterator3 = _createForOfIteratorHelper(properties),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var property = _step3.value;\n\n      // skip @id\n      if (property === '@id') {\n        continue;\n      } // handle reverse properties\n\n\n      if (property === '@reverse') {\n        var referencedNode = {\n          '@id': name\n        };\n        var reverseMap = input['@reverse'];\n\n        for (var reverseProperty in reverseMap) {\n          var items = reverseMap[reverseProperty];\n\n          var _iterator4 = _createForOfIteratorHelper(items),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var item = _step4.value;\n              var itemName = item['@id'];\n\n              if (graphTypes.isBlankNode(item)) {\n                itemName = issuer.getId(itemName);\n              }\n\n              api.createNodeMap(item, graphs, graph, issuer, itemName);\n              util.addValue(subjects[itemName], reverseProperty, referencedNode, {\n                propertyIsArray: true,\n                allowDuplicate: false\n              });\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        continue;\n      } // recurse into graph\n\n\n      if (property === '@graph') {\n        // add graph subjects map entry\n        if (!(name in graphs)) {\n          graphs[name] = {};\n        }\n\n        api.createNodeMap(input[property], graphs, name, issuer);\n        continue;\n      } // copy non-@type keywords\n\n\n      if (property !== '@type' && isKeyword(property)) {\n        if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {\n          throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {\n            code: 'conflicting indexes',\n            subject: subject\n          });\n        }\n\n        subject[property] = input[property];\n        continue;\n      } // iterate over objects\n\n\n      var objects = input[property]; // if property is a bnode, assign it a new id\n\n      if (property.indexOf('_:') === 0) {\n        property = issuer.getId(property);\n      } // ensure property is added for empty arrays\n\n\n      if (objects.length === 0) {\n        util.addValue(subject, property, [], {\n          propertyIsArray: true\n        });\n        continue;\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(objects),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var o = _step5.value;\n\n          if (property === '@type') {\n            // rename @type blank nodes\n            o = o.indexOf('_:') === 0 ? issuer.getId(o) : o;\n          } // handle embedded subject or subject reference\n\n\n          if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n            // relabel blank node @id\n            var id = graphTypes.isBlankNode(o) ? issuer.getId(o['@id']) : o['@id']; // add reference and recurse\n\n            util.addValue(subject, property, {\n              '@id': id\n            }, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n            api.createNodeMap(o, graphs, graph, issuer, id);\n          } else if (graphTypes.isValue(o)) {\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          } else if (graphTypes.isList(o)) {\n            // handle @list\n            var _list2 = [];\n            api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list2);\n            o = {\n              '@list': _list2\n            };\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          } else {\n            // handle @value\n            api.createNodeMap(o, graphs, graph, issuer, name);\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n};\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\n\n\napi.mergeNodeMapGraphs = function (graphs) {\n  var merged = {};\n\n  var _iterator6 = _createForOfIteratorHelper(Object.keys(graphs).sort()),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var name = _step6.value;\n\n      var _iterator7 = _createForOfIteratorHelper(Object.keys(graphs[name]).sort()),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var id = _step7.value;\n          var node = graphs[name][id];\n\n          if (!(id in merged)) {\n            merged[id] = {\n              '@id': id\n            };\n          }\n\n          var mergedNode = merged[id];\n\n          var _iterator8 = _createForOfIteratorHelper(Object.keys(node).sort()),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var property = _step8.value;\n\n              if (isKeyword(property)) {\n                // copy keywords\n                mergedNode[property] = util.clone(node[property]);\n              } else {\n                // merge objects\n                var _iterator9 = _createForOfIteratorHelper(node[property]),\n                    _step9;\n\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    var value = _step9.value;\n                    util.addValue(mergedNode, property, util.clone(value), {\n                      propertyIsArray: true,\n                      allowDuplicate: false\n                    });\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = function (graphs) {\n  // add all non-default graphs to default graph\n  var defaultGraph = graphs['@default'];\n  var graphNames = Object.keys(graphs).sort();\n\n  var _iterator10 = _createForOfIteratorHelper(graphNames),\n      _step10;\n\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var graphName = _step10.value;\n\n      if (graphName === '@default') {\n        continue;\n      }\n\n      var nodeMap = graphs[graphName];\n      var subject = defaultGraph[graphName];\n\n      if (!subject) {\n        defaultGraph[graphName] = subject = {\n          '@id': graphName,\n          '@graph': []\n        };\n      } else if (!('@graph' in subject)) {\n        subject['@graph'] = [];\n      }\n\n      var graph = subject['@graph'];\n\n      var _iterator11 = _createForOfIteratorHelper(Object.keys(nodeMap).sort()),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var id = _step11.value;\n          var node = nodeMap[id]; // only add full subjects\n\n          if (!graphTypes.isSubjectReference(node)) {\n            graph.push(node);\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n\n  return defaultGraph;\n};","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld/lib/nodeMap.js"],"names":["require","isKeyword","graphTypes","types","util","JsonLdError","api","module","exports","createMergedNodeMap","input","options","issuer","IdentifierIssuer","graphs","createNodeMap","mergeNodeMaps","graph","name","list","isArray","node","undefined","isObject","push","isValue","type","indexOf","getId","isList","_list","isUndefined","isBlankNode","subjects","subject","properties","Object","keys","sort","property","referencedNode","reverseMap","reverseProperty","items","item","itemName","addValue","propertyIsArray","allowDuplicate","code","objects","length","o","isSubject","isSubjectReference","id","mergeNodeMapGraphs","merged","mergedNode","clone","value","defaultGraph","graphNames","graphName","nodeMap"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\nconst JsonLdError = require('./JsonLdError');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if(types.isArray(input)) {\n    for(const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if(!types.isObject(input)) {\n    if(list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if(graphTypes.isValue(input)) {\n    if('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if(type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if(list) {\n      list.push(input);\n    }\n    return;\n  } else if(list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({'@list': _list});\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if('@type' in input) {\n    const types = input['@type'];\n    for(const type of types) {\n      if(type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if(types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ?\n      issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if(list) {\n    list.push({'@id': name});\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for(let property of properties) {\n    // skip @id\n    if(property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if(property === '@reverse') {\n      const referencedNode = {'@id': name};\n      const reverseMap = input['@reverse'];\n      for(const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for(const item of items) {\n          let itemName = item['@id'];\n          if(graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(\n            subjects[itemName], reverseProperty, referencedNode,\n            {propertyIsArray: true, allowDuplicate: false});\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if(property === '@graph') {\n      // add graph subjects map entry\n      if(!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if(property !== '@type' && isKeyword(property)) {\n      if(property === '@index' && property in subject &&\n        (input[property] !== subject[property] ||\n        input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; conflicting @index property detected.',\n          'jsonld.SyntaxError',\n          {code: 'conflicting indexes', subject});\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if(property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if(objects.length === 0) {\n      util.addValue(subject, property, [], {propertyIsArray: true});\n      continue;\n    }\n    for(let o of objects) {\n      if(property === '@type') {\n        // rename @type blank nodes\n        o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if(graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ?\n          issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(\n          subject, property, {'@id': id},\n          {propertyIsArray: true, allowDuplicate: false});\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if(graphTypes.isValue(o)) {\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else if(graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {'@list': _list};\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(\n          subject, property, o, {propertyIsArray: true, allowDuplicate: false});\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for(const name of Object.keys(graphs).sort()) {\n    for(const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if(!(id in merged)) {\n        merged[id] = {'@id': id};\n      }\n      const mergedNode = merged[id];\n\n      for(const property of Object.keys(node).sort()) {\n        if(isKeyword(property)) {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for(const value of node[property]) {\n            util.addValue(\n              mergedNode, property, util.clone(value),\n              {propertyIsArray: true, allowDuplicate: false});\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for(const graphName of graphNames) {\n    if(graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if(!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if(!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for(const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if(!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};\n"]},"metadata":{},"sourceType":"script"}