{"ast":null,"code":"/*\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _require = require('node-forge'),\n    asn1 = _require.asn1,\n    oids = _require.oids,\n    ByteBuffer = _require.util.ByteBuffer;\n/**\n * Wraps Base58 decoding operations in\n * order to provide consistent error messages.\n * @ignore\n * @example\n * > const pubkeyBytes = _base58Decode({\n *    decode: base58.decode,\n *    keyMaterial: this.publicKeyBase58,\n *    type: 'public'\n *   });\n * @param {Object} options - The decoder options.\n * @param {Function} options.decode - The decode function to use.\n * @param {string} options.keyMaterial - The Base58 encoded\n * key material to decode.\n * @param {string} options.type - A description of the\n * key material that will be included\n * in an error message (e.g. 'public', 'private').\n *\n * @returns {Object} - The decoded bytes. The data structure for the bytes is\n *   determined by the provided decode function.\n */\n\n\nexports.base58Decode = function (_ref) {\n  var decode = _ref.decode,\n      keyMaterial = _ref.keyMaterial,\n      type = _ref.type;\n  var bytes;\n\n  try {\n    bytes = decode(keyMaterial);\n  } catch (e) {// do nothing\n    // the bs58 implementation throws, forge returns undefined\n    // this helper throws when no result is produced\n  }\n\n  if (bytes === undefined) {\n    throw new TypeError(\"The \".concat(type, \" key material must be Base58 encoded.\"));\n  }\n\n  return bytes;\n};\n\nexports.privateKeyDerEncode = function (_ref2) {\n  var privateKeyBytes = _ref2.privateKeyBytes,\n      seedBytes = _ref2.seedBytes;\n\n  if (!(privateKeyBytes || seedBytes)) {\n    throw new TypeError('`privateKeyBytes` or `seedBytes` is required.');\n  }\n\n  if (!privateKeyBytes && !(Buffer.isBuffer(seedBytes) && seedBytes.length === 32)) {\n    throw new TypeError('`seedBytes` must be a 32 byte Buffer.');\n  }\n\n  if (!seedBytes && !(Buffer.isBuffer(privateKeyBytes) && privateKeyBytes.length === 64)) {\n    throw new TypeError('`privateKeyBytes` must be a 64 byte Buffer.');\n  }\n\n  var p;\n\n  if (seedBytes) {\n    p = seedBytes;\n  } else {\n    // extract the first 32 bytes of the 64 byte private key representation\n    p = Buffer.from(privateKeyBytes.buffer, privateKeyBytes.byteOffset, 32);\n  }\n\n  var keyBuffer = new ByteBuffer(p);\n  var asn1Key = asn1.create(asn1.UNIVERSAL, asn1.Type.OCTETSTRING, false, keyBuffer.getBytes());\n  var a = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()), // privateKeyAlgorithm\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids.EdDSA25519).getBytes())]), // private key\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(asn1Key).getBytes())]);\n  var privateKeyDer = asn1.toDer(a);\n  return Buffer.from(privateKeyDer.getBytes(), 'binary');\n};\n\nexports.publicKeyDerEncode = function (_ref3) {\n  var publicKeyBytes = _ref3.publicKeyBytes;\n\n  if (!(Buffer.isBuffer(publicKeyBytes) && publicKeyBytes.length === 32)) {\n    throw new TypeError('`publicKeyBytes` must be a 32 byte Buffer.');\n  } // add a zero byte to the front of the publicKeyBytes, this results in\n  // the bitstring being 256 bits vs. 170 bits (without padding)\n\n\n  var zeroBuffer = Buffer.from(new Uint8Array([0]));\n  var keyBuffer = new ByteBuffer(Buffer.concat([zeroBuffer, publicKeyBytes]));\n  var a = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids.EdDSA25519).getBytes())]), // public key\n  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, keyBuffer.getBytes())]);\n  var publicKeyDer = asn1.toDer(a);\n  return Buffer.from(publicKeyDer.getBytes(), 'binary');\n};","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/crypto-ld/lib/util.js"],"names":["require","asn1","oids","ByteBuffer","util","exports","base58Decode","decode","keyMaterial","type","bytes","e","undefined","TypeError","privateKeyDerEncode","privateKeyBytes","seedBytes","Buffer","isBuffer","length","p","from","buffer","byteOffset","keyBuffer","asn1Key","create","UNIVERSAL","Type","OCTETSTRING","getBytes","a","Class","SEQUENCE","INTEGER","integerToDer","OID","oidToDer","EdDSA25519","toDer","privateKeyDer","publicKeyDerEncode","publicKeyBytes","zeroBuffer","Uint8Array","concat","BITSTRING","publicKeyDer"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {asn1, oids, util: {ByteBuffer}} = require('node-forge');\n\n/**\n * Wraps Base58 decoding operations in\n * order to provide consistent error messages.\n * @ignore\n * @example\n * > const pubkeyBytes = _base58Decode({\n *    decode: base58.decode,\n *    keyMaterial: this.publicKeyBase58,\n *    type: 'public'\n *   });\n * @param {Object} options - The decoder options.\n * @param {Function} options.decode - The decode function to use.\n * @param {string} options.keyMaterial - The Base58 encoded\n * key material to decode.\n * @param {string} options.type - A description of the\n * key material that will be included\n * in an error message (e.g. 'public', 'private').\n *\n * @returns {Object} - The decoded bytes. The data structure for the bytes is\n *   determined by the provided decode function.\n */\nexports.base58Decode = ({decode, keyMaterial, type}) => {\n  let bytes;\n  try {\n    bytes = decode(keyMaterial);\n  } catch(e) {\n    // do nothing\n    // the bs58 implementation throws, forge returns undefined\n    // this helper throws when no result is produced\n  }\n  if(bytes === undefined) {\n    throw new TypeError(`The ${type} key material must be Base58 encoded.`);\n  }\n  return bytes;\n};\n\nexports.privateKeyDerEncode = ({privateKeyBytes, seedBytes}) => {\n  if(!(privateKeyBytes || seedBytes)) {\n    throw new TypeError('`privateKeyBytes` or `seedBytes` is required.');\n  }\n  if(!privateKeyBytes && !(Buffer.isBuffer(seedBytes) &&\n    seedBytes.length === 32)) {\n    throw new TypeError('`seedBytes` must be a 32 byte Buffer.');\n  }\n  if(!seedBytes && !(Buffer.isBuffer(privateKeyBytes) &&\n    privateKeyBytes.length === 64)) {\n    throw new TypeError('`privateKeyBytes` must be a 64 byte Buffer.');\n  }\n  let p;\n  if(seedBytes) {\n    p = seedBytes;\n  } else {\n    // extract the first 32 bytes of the 64 byte private key representation\n    p = Buffer.from(privateKeyBytes.buffer, privateKeyBytes.byteOffset, 32);\n  }\n  const keyBuffer = new ByteBuffer(p);\n\n  const asn1Key = asn1.create(\n    asn1.UNIVERSAL,\n    asn1.Type.OCTETSTRING,\n    false,\n    keyBuffer.getBytes()\n  );\n\n  const a = asn1.create(\n    asn1.Class.UNIVERSAL,\n    asn1.Type.SEQUENCE,\n    true, [\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false,\n        asn1.integerToDer(0).getBytes()),\n      // privateKeyAlgorithm\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(oids.EdDSA25519).getBytes()\n        ),\n      ]),\n      // private key\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false,\n        asn1.toDer(asn1Key).getBytes()),\n    ]\n  );\n\n  const privateKeyDer = asn1.toDer(a);\n  return Buffer.from(privateKeyDer.getBytes(), 'binary');\n};\n\nexports.publicKeyDerEncode = ({publicKeyBytes}) => {\n  if(!(Buffer.isBuffer(publicKeyBytes) && publicKeyBytes.length === 32)) {\n    throw new TypeError('`publicKeyBytes` must be a 32 byte Buffer.');\n  }\n  // add a zero byte to the front of the publicKeyBytes, this results in\n  // the bitstring being 256 bits vs. 170 bits (without padding)\n  const zeroBuffer = Buffer.from(new Uint8Array([0]));\n  const keyBuffer = new ByteBuffer(Buffer.concat([zeroBuffer, publicKeyBytes]));\n\n  const a = asn1.create(\n    asn1.Class.UNIVERSAL,\n    asn1.Type.SEQUENCE,\n    true, [\n      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [\n        asn1.create(\n          asn1.Class.UNIVERSAL,\n          asn1.Type.OID,\n          false,\n          asn1.oidToDer(oids.EdDSA25519).getBytes()\n        ),\n      ]),\n      // public key\n      asn1.create(\n        asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false,\n        keyBuffer.getBytes()),\n    ]\n  );\n\n  const publicKeyDer = asn1.toDer(a);\n  return Buffer.from(publicKeyDer.getBytes(), 'binary');\n};\n"]},"metadata":{},"sourceType":"script"}