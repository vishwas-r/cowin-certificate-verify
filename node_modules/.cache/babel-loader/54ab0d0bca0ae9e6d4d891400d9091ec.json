{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Symbol = void 0;\n\nvar enum_1 = require(\"./enum\");\n\nvar TypePointer = function TypePointer(ptr, buf) {\n  _classCallCheck(this, TypePointer);\n\n  this.ptr = ptr;\n  this.ptr32 = ptr >> 2;\n  this.buf = buf;\n  this.HEAP8 = new Int8Array(buf);\n  this.HEAPU32 = new Uint32Array(buf);\n  this.HEAP32 = new Int32Array(buf);\n};\n\nvar SymbolPtr = /*#__PURE__*/function (_TypePointer) {\n  _inherits(SymbolPtr, _TypePointer);\n\n  var _super = _createSuper(SymbolPtr);\n\n  function SymbolPtr() {\n    _classCallCheck(this, SymbolPtr);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(SymbolPtr, [{\n    key: \"type\",\n    get: function get() {\n      return this.HEAPU32[this.ptr32];\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      var len = this.HEAPU32[this.ptr32 + 2];\n      var ptr = this.HEAPU32[this.ptr32 + 3];\n      return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));\n    }\n  }, {\n    key: \"points\",\n    get: function get() {\n      var len = this.HEAPU32[this.ptr32 + 5];\n      var ptr = this.HEAPU32[this.ptr32 + 6];\n      var ptr32 = ptr >> 2;\n      var res = [];\n\n      for (var i = 0; i < len; ++i) {\n        var x = this.HEAP32[ptr32 + i * 2];\n        var y = this.HEAP32[ptr32 + i * 2 + 1];\n        res.push({\n          x: x,\n          y: y\n        });\n      }\n\n      return res;\n    }\n  }, {\n    key: \"next\",\n    get: function get() {\n      var ptr = this.HEAPU32[this.ptr32 + 8];\n      if (!ptr) return null;\n      return new SymbolPtr(ptr, this.buf);\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      return this.HEAPU32[this.ptr32 + 10];\n    }\n  }, {\n    key: \"cacheCount\",\n    get: function get() {\n      return this.HEAP32[this.ptr32 + 11];\n    }\n  }, {\n    key: \"quality\",\n    get: function get() {\n      return this.HEAP32[this.ptr32 + 12];\n    }\n  }]);\n\n  return SymbolPtr;\n}(TypePointer);\n\nvar SymbolSetPtr = /*#__PURE__*/function (_TypePointer2) {\n  _inherits(SymbolSetPtr, _TypePointer2);\n\n  var _super2 = _createSuper(SymbolSetPtr);\n\n  function SymbolSetPtr() {\n    _classCallCheck(this, SymbolSetPtr);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(SymbolSetPtr, [{\n    key: \"head\",\n    get: function get() {\n      var ptr = this.HEAPU32[this.ptr32 + 2];\n      if (!ptr) return null;\n      return new SymbolPtr(ptr, this.buf);\n    }\n  }]);\n\n  return SymbolSetPtr;\n}(TypePointer);\n\nvar Symbol = /*#__PURE__*/function () {\n  function Symbol(ptr) {\n    _classCallCheck(this, Symbol);\n\n    this.type = ptr.type;\n    this.typeName = enum_1.ZBarSymbolType[this.type];\n    this.data = ptr.data;\n    this.points = ptr.points;\n    this.time = ptr.time;\n    this.cacheCount = ptr.cacheCount;\n    this.quality = ptr.quality;\n  }\n\n  _createClass(Symbol, [{\n    key: \"decode\",\n    value: function decode(encoding) {\n      var decoder = new TextDecoder(encoding);\n      return decoder.decode(this.data);\n    }\n  }], [{\n    key: \"createSymbolsFromPtr\",\n    value: function createSymbolsFromPtr(ptr, buf) {\n      if (ptr == 0) return [];\n      var set = new SymbolSetPtr(ptr, buf);\n      var symbol = set.head;\n      var res = [];\n\n      while (symbol !== null) {\n        res.push(new Symbol(symbol));\n        symbol = symbol.next;\n      }\n\n      return res;\n    }\n  }]);\n\n  return Symbol;\n}();\n\nexports.Symbol = Symbol;","map":{"version":3,"sources":["../src/Symbol.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Symbol = void 0;\nconst enum_1 = require(\"./enum\");\nclass TypePointer {\n    constructor(ptr, buf) {\n        this.ptr = ptr;\n        this.ptr32 = ptr >> 2;\n        this.buf = buf;\n        this.HEAP8 = new Int8Array(buf);\n        this.HEAPU32 = new Uint32Array(buf);\n        this.HEAP32 = new Int32Array(buf);\n    }\n}\nclass SymbolPtr extends TypePointer {\n    get type() {\n        return this.HEAPU32[this.ptr32];\n    }\n    get data() {\n        const len = this.HEAPU32[this.ptr32 + 2];\n        const ptr = this.HEAPU32[this.ptr32 + 3];\n        return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));\n    }\n    get points() {\n        const len = this.HEAPU32[this.ptr32 + 5];\n        const ptr = this.HEAPU32[this.ptr32 + 6];\n        const ptr32 = ptr >> 2;\n        const res = [];\n        for (let i = 0; i < len; ++i) {\n            const x = this.HEAP32[ptr32 + i * 2];\n            const y = this.HEAP32[ptr32 + i * 2 + 1];\n            res.push({ x, y });\n        }\n        return res;\n    }\n    get next() {\n        const ptr = this.HEAPU32[this.ptr32 + 8];\n        if (!ptr)\n            return null;\n        return new SymbolPtr(ptr, this.buf);\n    }\n    get time() {\n        return this.HEAPU32[this.ptr32 + 10];\n    }\n    get cacheCount() {\n        return this.HEAP32[this.ptr32 + 11];\n    }\n    get quality() {\n        return this.HEAP32[this.ptr32 + 12];\n    }\n}\nclass SymbolSetPtr extends TypePointer {\n    get head() {\n        const ptr = this.HEAPU32[this.ptr32 + 2];\n        if (!ptr)\n            return null;\n        return new SymbolPtr(ptr, this.buf);\n    }\n}\nclass Symbol {\n    constructor(ptr) {\n        this.type = ptr.type;\n        this.typeName = enum_1.ZBarSymbolType[this.type];\n        this.data = ptr.data;\n        this.points = ptr.points;\n        this.time = ptr.time;\n        this.cacheCount = ptr.cacheCount;\n        this.quality = ptr.quality;\n    }\n    static createSymbolsFromPtr(ptr, buf) {\n        if (ptr == 0)\n            return [];\n        const set = new SymbolSetPtr(ptr, buf);\n        let symbol = set.head;\n        const res = [];\n        while (symbol !== null) {\n            res.push(new Symbol(symbol));\n            symbol = symbol.next;\n        }\n        return res;\n    }\n    decode(encoding) {\n        const decoder = new TextDecoder(encoding);\n        return decoder.decode(this.data);\n    }\n}\nexports.Symbol = Symbol;\n//# sourceMappingURL=Symbol.js.map"]},"metadata":{},"sourceType":"script"}