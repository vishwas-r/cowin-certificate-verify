{"ast":null,"code":"/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar graphTypes = require('./graphTypes');\n\nvar types = require('./types'); // TODO: move `IdentifierIssuer` to its own package\n\n\nvar IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\n\nvar JsonLdError = require('./JsonLdError'); // constants\n\n\nvar REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nvar REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nvar REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\nvar DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\nvar api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\n\napi.clone = function (value) {\n  if (value && typeof value === 'object') {\n    var rval;\n\n    if (types.isArray(value)) {\n      rval = [];\n\n      for (var i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if (value instanceof Map) {\n      rval = new Map();\n\n      var _iterator = _createForOfIteratorHelper(value),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              k = _step$value[0],\n              v = _step$value[1];\n\n          rval.set(k, api.clone(v));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else if (value instanceof Set) {\n      rval = new Set();\n\n      var _iterator2 = _createForOfIteratorHelper(value),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _v = _step2.value;\n          rval.add(api.clone(_v));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (types.isObject(value)) {\n      rval = {};\n\n      for (var key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n\n    return rval;\n  }\n\n  return value;\n};\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\n\n\napi.asArray = function (value) {\n  return Array.isArray(value) ? value : [value];\n};\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\n\n\napi.buildHeaders = function () {\n  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var hasAccept = Object.keys(headers).some(function (h) {\n    return h.toLowerCase() === 'accept';\n  });\n\n  if (hasAccept) {\n    throw new RangeError('Accept header may not be specified; only \"' + DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({\n    Accept: DEFAULTS.headers.accept\n  }, headers);\n};\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\n\n\napi.parseLinkHeader = function (header) {\n  var rval = {}; // split on unbracketed/unquoted commas\n\n  var entries = header.match(REGEX_LINK_HEADERS);\n\n  for (var i = 0; i < entries.length; ++i) {\n    var match = entries[i].match(REGEX_LINK_HEADER);\n\n    if (!match) {\n      continue;\n    }\n\n    var result = {\n      target: match[1]\n    };\n    var params = match[2];\n\n    while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {\n      result[match[1]] = match[2] === undefined ? match[3] : match[2];\n    }\n\n    var rel = result['rel'] || '';\n\n    if (Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if (rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n\n  return rval;\n};\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\n\n\napi.validateTypeValue = function (v) {\n  // can be a string or an empty object\n  if (types.isString(v) || types.isEmptyObject(v)) {\n    return;\n  } // must be an array\n\n\n  var isValid = false;\n\n  if (types.isArray(v)) {\n    // must contain only strings\n    isValid = true;\n\n    for (var i = 0; i < v.length; ++i) {\n      if (!types.isString(v[i])) {\n        isValid = false;\n        break;\n      }\n    }\n  }\n\n  if (!isValid) {\n    throw new JsonLdError('Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' + 'strings, or an empty object.', 'jsonld.SyntaxError', {\n      code: 'invalid type value',\n      value: v\n    });\n  }\n};\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\n\n\napi.hasProperty = function (subject, property) {\n  if (subject.hasOwnProperty(property)) {\n    var value = subject[property];\n    return !types.isArray(value) || value.length > 0;\n  }\n\n  return false;\n};\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\n\n\napi.hasValue = function (subject, property, value) {\n  if (api.hasProperty(subject, property)) {\n    var val = subject[property];\n    var isList = graphTypes.isList(val);\n\n    if (types.isArray(val) || isList) {\n      if (isList) {\n        val = val['@list'];\n      }\n\n      for (var i = 0; i < val.length; ++i) {\n        if (api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if (!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n\n  return false;\n};\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\n\n\napi.addValue = function (subject, property, value, options) {\n  options = options || {};\n\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  if (!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n\n  if (!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n\n  if (!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if (options.valueIsArray) {\n    subject[property] = value;\n  } else if (types.isArray(value)) {\n    if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n\n    if (options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n\n    for (var i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if (subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    var hasValue = !options.allowDuplicate && api.hasValue(subject, property, value); // make property an array if value not present or always an array\n\n    if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    } // add new value\n\n\n    if (!hasValue) {\n      if (options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\n\n\napi.getValues = function (subject, property) {\n  return [].concat(subject[property] || []);\n};\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\n\n\napi.removeProperty = function (subject, property) {\n  delete subject[property];\n};\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\n\n\napi.removeValue = function (subject, property, value, options) {\n  options = options || {};\n\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  } // filter out value\n\n\n  var values = api.getValues(subject, property).filter(function (e) {\n    return !api.compareValues(e, value);\n  });\n\n  if (values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if (values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\n\n\napi.relabelBlankNodes = function (input, options) {\n  options = options || {};\n  var issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\n\n\napi.compareValues = function (v1, v2) {\n  // 1. equal primitives\n  if (v1 === v2) {\n    return true;\n  } // 2. equal @values\n\n\n  if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1['@value'] === v2['@value'] && v1['@type'] === v2['@type'] && v1['@language'] === v2['@language'] && v1['@index'] === v2['@index']) {\n    return true;\n  } // 3. equal @ids\n\n\n  if (types.isObject(v1) && '@id' in v1 && types.isObject(v2) && '@id' in v2) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\n\n\napi.compareShortestLeast = function (a, b) {\n  if (a.length < b.length) {\n    return -1;\n  }\n\n  if (b.length < a.length) {\n    return 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  return a < b ? -1 : 1;\n};\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\n\n\nfunction _labelBlankNodes(issuer, element) {\n  if (types.isArray(element)) {\n    for (var i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if (graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if (types.isObject(element)) {\n    // relabel blank node\n    if (graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    } // recursively apply to all keys\n\n\n    var keys = Object.keys(element).sort();\n\n    for (var ki = 0; ki < keys.length; ++ki) {\n      var key = keys[ki];\n\n      if (key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld/lib/util.js"],"names":["graphTypes","require","types","IdentifierIssuer","JsonLdError","REGEX_LINK_HEADERS","REGEX_LINK_HEADER","REGEX_LINK_HEADER_PARAMS","DEFAULTS","headers","accept","api","module","exports","clone","value","rval","isArray","i","length","Map","k","v","set","Set","add","isObject","key","toString","asArray","Array","buildHeaders","hasAccept","Object","keys","some","h","toLowerCase","RangeError","assign","Accept","parseLinkHeader","header","entries","match","result","target","params","exec","undefined","rel","push","hasOwnProperty","validateTypeValue","isString","isEmptyObject","isValid","code","hasProperty","subject","property","hasValue","val","isList","compareValues","addValue","options","propertyIsArray","valueIsArray","allowDuplicate","prependValue","concat","unshift","getValues","removeProperty","removeValue","values","filter","e","relabelBlankNodes","input","issuer","_labelBlankNodes","v1","v2","isValue","compareShortestLeast","a","b","element","isBlankNode","getId","sort","ki"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\n// TODO: move `IdentifierIssuer` to its own package\nconst IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\n\n// constants\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS =\n  /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\n\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\n\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function(value) {\n  if(value && typeof value === 'object') {\n    let rval;\n    if(types.isArray(value)) {\n      rval = [];\n      for(let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if(value instanceof Map) {\n      rval = new Map();\n      for(const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if(value instanceof Set) {\n      rval = new Set();\n      for(const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if(types.isObject(value)) {\n      rval = {};\n      for(const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(\n    h => h.toLowerCase() === 'accept');\n\n  if(hasAccept) {\n    throw new RangeError(\n      'Accept header may not be specified; only \"' +\n      DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({Accept: DEFAULTS.headers.accept}, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = header => {\n  const rval = {};\n  // split on unbracketed/unquoted commas\n  const entries = header.match(REGEX_LINK_HEADERS);\n  for(let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n    if(!match) {\n      continue;\n    }\n    const result = {target: match[1]};\n    const params = match[2];\n    while((match = REGEX_LINK_HEADER_PARAMS.exec(params))) {\n      result[match[1]] = (match[2] === undefined) ? match[3] : match[2];\n    }\n    const rel = result['rel'] || '';\n    if(Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if(rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = v => {\n  // can be a string or an empty object\n  if(types.isString(v) || types.isEmptyObject(v)) {\n    return;\n  }\n\n  // must be an array\n  let isValid = false;\n  if(types.isArray(v)) {\n    // must contain only strings\n    isValid = true;\n    for(let i = 0; i < v.length; ++i) {\n      if(!(types.isString(v[i]))) {\n        isValid = false;\n        break;\n      }\n    }\n  }\n\n  if(!isValid) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' +\n      'strings, or an empty object.', 'jsonld.SyntaxError',\n      {code: 'invalid type value', value: v});\n  }\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = (subject, property) => {\n  if(subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return (!types.isArray(value) || value.length > 0);\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = (subject, property, value) => {\n  if(api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n    if(types.isArray(val) || isList) {\n      if(isList) {\n        val = val['@list'];\n      }\n      for(let i = 0; i < val.length; ++i) {\n        if(api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if(!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if(!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if(!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n  if(!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if(options.valueIsArray) {\n    subject[property] = value;\n  } else if(types.isArray(value)) {\n    if(value.length === 0 && options.propertyIsArray &&\n      !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    if(options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n    for(let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if(subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = (!options.allowDuplicate &&\n      api.hasValue(subject, property, value));\n\n    // make property an array if value not present or always an array\n    if(!types.isArray(subject[property]) &&\n      (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if(!hasValue) {\n      if(options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  const values = api.getValues(subject, property).filter(\n    e => !api.compareValues(e, value));\n\n  if(values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if(values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if(v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if(graphTypes.isValue(v1) && graphTypes.isValue(v2) &&\n    v1['@value'] === v2['@value'] &&\n    v1['@type'] === v2['@type'] &&\n    v1['@language'] === v2['@language'] &&\n    v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if(types.isObject(v1) &&\n    ('@id' in v1) &&\n    types.isObject(v2) &&\n    ('@id' in v2)) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = (a, b) => {\n  if(a.length < b.length) {\n    return -1;\n  }\n  if(b.length < a.length) {\n    return 1;\n  }\n  if(a === b) {\n    return 0;\n  }\n  return (a < b) ? -1 : 1;\n};\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if(types.isArray(element)) {\n    for(let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if(graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if(types.isObject(element)) {\n    // relabel blank node\n    if(graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    const keys = Object.keys(element).sort();\n    for(let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n      if(key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}\n"]},"metadata":{},"sourceType":"script"}