{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require('./nodeMap'),\n    createNodeMap = _require.createNodeMap;\n\nvar _require2 = require('./context'),\n    isKeyword = _require2.isKeyword;\n\nvar graphTypes = require('./graphTypes');\n\nvar jsonCanonicalize = require('canonicalize');\n\nvar types = require('./types');\n\nvar util = require('./util');\n\nvar _require3 = require('./constants'),\n    RDF_FIRST = _require3.RDF_FIRST,\n    RDF_REST = _require3.RDF_REST,\n    RDF_NIL = _require3.RDF_NIL,\n    RDF_TYPE = _require3.RDF_TYPE,\n    RDF_JSON_LITERAL = _require3.RDF_JSON_LITERAL,\n    RDF_LANGSTRING = _require3.RDF_LANGSTRING,\n    XSD_BOOLEAN = _require3.XSD_BOOLEAN,\n    XSD_DOUBLE = _require3.XSD_DOUBLE,\n    XSD_INTEGER = _require3.XSD_INTEGER,\n    XSD_STRING = _require3.XSD_STRING;\n\nvar _require4 = require('./url'),\n    _isAbsoluteIri = _require4.isAbsolute;\n\nvar api = {};\nmodule.exports = api;\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\n\napi.toRDF = function (input, options) {\n  // create node map for default graph (and any named graphs)\n  var issuer = new util.IdentifierIssuer('_:b');\n  var nodeMap = {\n    '@default': {}\n  };\n  createNodeMap(input, nodeMap, '@default', issuer);\n  var dataset = [];\n  var graphNames = Object.keys(nodeMap).sort();\n\n  var _iterator = _createForOfIteratorHelper(graphNames),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var graphName = _step.value;\n      var graphTerm = void 0;\n\n      if (graphName === '@default') {\n        graphTerm = {\n          termType: 'DefaultGraph',\n          value: ''\n        };\n      } else if (_isAbsoluteIri(graphName)) {\n        if (graphName.startsWith('_:')) {\n          graphTerm = {\n            termType: 'BlankNode'\n          };\n        } else {\n          graphTerm = {\n            termType: 'NamedNode'\n          };\n        }\n\n        graphTerm.value = graphName;\n      } else {\n        // skip relative IRIs (not valid RDF)\n        continue;\n      }\n\n      _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return dataset;\n};\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\n\n\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  var ids = Object.keys(graph).sort();\n\n  var _iterator2 = _createForOfIteratorHelper(ids),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var id = _step2.value;\n      var node = graph[id];\n      var properties = Object.keys(node).sort();\n\n      var _iterator3 = _createForOfIteratorHelper(properties),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var property = _step3.value;\n          var items = node[property];\n\n          if (property === '@type') {\n            property = RDF_TYPE;\n          } else if (isKeyword(property)) {\n            continue;\n          }\n\n          var _iterator4 = _createForOfIteratorHelper(items),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var item = _step4.value;\n              // RDF subject\n              var subject = {\n                termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n                value: id\n              }; // skip relative IRI subjects (not valid RDF)\n\n              if (!_isAbsoluteIri(id)) {\n                continue;\n              } // RDF predicate\n\n\n              var predicate = {\n                termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n                value: property\n              }; // skip relative IRI predicates (not valid RDF)\n\n              if (!_isAbsoluteIri(property)) {\n                continue;\n              } // skip blank node predicates unless producing generalized RDF\n\n\n              if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {\n                continue;\n              } // convert list, value or node object to triple\n\n\n              var object = _objectToRDF(item, issuer, dataset, graphTerm); // skip null objects (they are relative IRIs)\n\n\n              if (object) {\n                dataset.push({\n                  subject: subject,\n                  predicate: predicate,\n                  object: object,\n                  graph: graphTerm\n                });\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\n\n\nfunction _listToRDF(list, issuer, dataset, graphTerm) {\n  var first = {\n    termType: 'NamedNode',\n    value: RDF_FIRST\n  };\n  var rest = {\n    termType: 'NamedNode',\n    value: RDF_REST\n  };\n  var nil = {\n    termType: 'NamedNode',\n    value: RDF_NIL\n  };\n  var last = list.pop(); // Result is the head of the list\n\n  var result = last ? {\n    termType: 'BlankNode',\n    value: issuer.getId()\n  } : nil;\n  var subject = result;\n\n  var _iterator5 = _createForOfIteratorHelper(list),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var item = _step5.value;\n\n      var _object = _objectToRDF(item, issuer, dataset, graphTerm);\n\n      var next = {\n        termType: 'BlankNode',\n        value: issuer.getId()\n      };\n      dataset.push({\n        subject: subject,\n        predicate: first,\n        object: _object,\n        graph: graphTerm\n      });\n      dataset.push({\n        subject: subject,\n        predicate: rest,\n        object: next,\n        graph: graphTerm\n      });\n      subject = next;\n    } // Tail of list\n\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  if (last) {\n    var object = _objectToRDF(last, issuer, dataset, graphTerm);\n\n    dataset.push({\n      subject: subject,\n      predicate: first,\n      object: object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject: subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\n\n\nfunction _objectToRDF(item, issuer, dataset, graphTerm) {\n  var object = {}; // convert value object to RDF\n\n  if (graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    var value = item['@value'];\n    var datatype = item['@type'] || null; // convert to XSD/JSON datatypes as appropriate\n\n    if (datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if (types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if (!types.isDouble(value)) {\n        value = parseFloat(value);\n      } // canonical double representation\n\n\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if (types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if ('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if (graphTypes.isList(item)) {\n    var _list = _listToRDF(item['@list'], issuer, dataset, graphTerm);\n\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    var id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  } // skip relative IRIs, not valid RDF\n\n\n  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/jsonld/lib/toRdf.js"],"names":["require","createNodeMap","isKeyword","graphTypes","jsonCanonicalize","types","util","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","RDF_LANGSTRING","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","_isAbsoluteIri","isAbsolute","api","module","exports","toRDF","input","options","issuer","IdentifierIssuer","nodeMap","dataset","graphNames","Object","keys","sort","graphName","graphTerm","termType","value","startsWith","_graphToRDF","graph","ids","id","node","properties","property","items","item","subject","predicate","produceGeneralizedRdf","object","_objectToRDF","push","_listToRDF","list","first","rest","nil","last","pop","result","getId","next","isValue","undefined","datatype","isBoolean","toString","isDouble","parseFloat","toExponential","replace","isNumber","toFixed","language","isList","_list","isObject"],"mappings":"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","sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {createNodeMap} = require('./nodeMap');\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst jsonCanonicalize = require('canonicalize');\nconst types = require('./types');\nconst util = require('./util');\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object = _objectToRDF(item, issuer, dataset, graphTerm);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list = _listToRDF(item['@list'], issuer, dataset, graphTerm);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}\n"]},"metadata":{},"sourceType":"script"}