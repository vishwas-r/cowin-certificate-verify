{"ast":null,"code":"/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _objectSpread = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"D:/My Works/Git/cowin-verify/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar env = require('./env');\n\nvar forge = require('node-forge');\n\nvar sha256 = forge.md.sha256,\n    _forge$pki = forge.pki,\n    getPublicKeyFingerprint = _forge$pki.getPublicKeyFingerprint,\n    publicKeyFromPem = _forge$pki.publicKeyFromPem,\n    _forge$util$binary = forge.util.binary,\n    base58 = _forge$util$binary.base58,\n    raw = _forge$util$binary.raw;\n\nvar LDKeyPair = require('./LDKeyPair');\n/**\n * @constant\n * @type {number}\n * @default\n */\n\n\nvar DEFAULT_RSA_KEY_BITS = 2048;\n/**\n * @constant\n * @type {number}\n * @default\n */\n\nvar DEFAULT_RSA_EXPONENT = 0x10001;\n\nvar RSAKeyPair = /*#__PURE__*/function (_LDKeyPair) {\n  _inherits(RSAKeyPair, _LDKeyPair);\n\n  var _super = _createSuper(RSAKeyPair);\n\n  /* eslint-disable max-len */\n\n  /**\n   * An implementation of\n   * [RSA encryption]{@link https://simple.wikipedia.org/wiki/RSA_algorithm}\n   * for\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * @example\n   * > const options = {\n   *    privateKeyPem: 'testPrivateKey',\n   *    publicKeyPem: 'testPublicKey'\n   *  };\n   * > const RSAKey = new RSAKeyPair(options);\n   * @param {KeyPairOptions} options - Keys must be in RSA format other\n   * options must follow [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} options.publicKeyPem - Public Key for Signatures.\n   * @param {string} options.privateKeyPem - Your Confidential key for signing.\n   */\n\n  /* eslint-enable */\n  function RSAKeyPair() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, RSAKeyPair);\n\n    _this = _super.call(this, options);\n    _this.type = 'RsaVerificationKey2018';\n    _this.privateKeyPem = options.privateKeyPem;\n    _this.publicKeyPem = options.publicKeyPem;\n\n    _this.validateKeyParams(); // validate keyBits and exponent\n\n\n    return _this;\n  }\n  /**\n   * Returns the public key.\n   * @implements {LDKeyPair#publicKey}\n   * @readonly\n   *\n   * @returns {string} The public key.\n   * @see [publicKey]{@link ./LDKeyPair.md#publicKey}\n   */\n\n\n  _createClass(RSAKeyPair, [{\n    key: \"publicKey\",\n    get: function get() {\n      return this.publicKeyPem;\n    }\n    /**\n     * Returns the private key.\n     * @implements {LDKeyPair#privateKey}\n     * @readonly\n     *\n     * @returns {string} The private key.\n     * @see [privateKey]{@link ./LDKeyPair.md#privateKey}\n     */\n\n  }, {\n    key: \"privateKey\",\n    get: function get() {\n      return this.privateKeyPem;\n    }\n    /**\n     * Generates an RSA KeyPair using the RSA Defaults.\n     * @example\n     * > const keyPair = await RSAKeyPair.generate();\n     * > keyPair\n     * RSAKeyPair { ...\n     * @param {KeyPairOptions} [options={}] - See LDKeyPair\n     * docstring for full list.\n     *\n     * @returns {Promise<RSAKeyPair>} A Default encrypted RSA KeyPair.\n     * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n     */\n\n  }, {\n    key: \"validateKeyParams\",\n    value:\n    /**\n     * Validates this key.\n     * @example\n     * > rsaKeyPair.validateKeyParams();\n     * undefined\n     *\n     * @returns {undefined} If it does not throw then the key is valid.\n     * @throws Invalid RSA keyBit length\n     * @throws Invalid RSA exponent\n     */\n    function validateKeyParams() {\n      if (this.publicKeyPem) {\n        var publicKey = forge.pki.publicKeyFromPem(this.publicKeyPem);\n        var keyBits = publicKey.n.bitLength();\n\n        if (keyBits !== DEFAULT_RSA_KEY_BITS) {\n          throw new Error(\"Invalid RSA keyBit length \".concat(JSON.stringify(keyBits)) + \" required value is \".concat(DEFAULT_RSA_KEY_BITS));\n        }\n\n        if (publicKey.e.toString(10) !== '65537') {\n          throw new Error(\"Invalid RSA exponent \".concat(JSON.stringify(publicKey.e.toString(10))) + ' required value is 65537}');\n        }\n      }\n\n      if (this.privateKeyPem) {\n        var privateKey = forge.pki.privateKeyFromPem(this.privateKeyPem);\n\n        var _keyBits = privateKey.n.bitLength();\n\n        if (_keyBits !== DEFAULT_RSA_KEY_BITS) {\n          throw new Error(\"Invalid RSA keyBit length \".concat(JSON.stringify(_keyBits)) + \" required value is \".concat(DEFAULT_RSA_KEY_BITS));\n        }\n\n        if (privateKey.e.toString(10) !== '65537') {\n          throw new Error(\"Invalid RSA exponent \".concat(JSON.stringify(privateKey.e.toString(10))) + ' required value is 65537}');\n        }\n      }\n    }\n    /**\n     * Adds this KeyPair's publicKeyPem to a public node.\n     * @example\n     * > rsaKeyPair.addEncodedPublicKey({id: 'testnode'});\n     * { publicKeyPem: 'testPublicKey' }\n     * @param {KeyPairOptions} publicKeyNode - A Node with out a publicKeyPem set.\n     *\n     * @returns {KeyPairOptions} A public node with a publicKeyPem set.\n     * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n     */\n\n  }, {\n    key: \"addEncodedPublicKey\",\n    value: function addEncodedPublicKey(publicKeyNode) {\n      publicKeyNode.publicKeyPem = this.publicKeyPem;\n      return publicKeyNode;\n    }\n    /**\n     * Adds this KeyPair's privateKeyPem to a public node.\n     * @example\n     * > rsaKeyPair.addEncryptedPrivateKey({id: 'testnode'});\n     * { privateKeyPem: 'testPrivateKey' }\n     * @param {KeyPairOptions} keyNode - A Node with out a publicKeyPem set.\n     *\n     * @returns {KeyPairOptions} A public node with a privateKeyPem set.\n     * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n     */\n\n  }, {\n    key: \"addEncryptedPrivateKey\",\n    value: function () {\n      var _addEncryptedPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(keyNode) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.passphrase !== null) {\n                  keyNode.privateKeyPem = forge.pki.encryptRsaPrivateKey(forge.pki.privateKeyFromPem(this.privateKeyPem), this.passphrase, {\n                    algorithm: 'aes256'\n                  });\n                } else {\n                  // no passphrase, do not encrypt private key\n                  keyNode.privateKeyPem = this.privateKeyPem;\n                }\n\n                return _context.abrupt(\"return\", keyNode);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function addEncryptedPrivateKey(_x) {\n        return _addEncryptedPrivateKey.apply(this, arguments);\n      }\n\n      return addEncryptedPrivateKey;\n    }()\n    /**\n     * Generates and returns a multiformats\n     * encoded RSA public key fingerprint (for use with cryptonyms, for example).\n     * @example\n     * > rsaKeyPair.fingerprint();\n     * 3423dfdsf3432sdfdsds\n     *\n     * @returns {string} An RSA fingerprint.\n     */\n\n  }, {\n    key: \"fingerprint\",\n    value: function fingerprint() {\n      var buffer = forge.util.createBuffer(); // use SubjectPublicKeyInfo fingerprint\n\n      var fingerprintBuffer = forge.pki.getPublicKeyFingerprint(forge.pki.publicKeyFromPem(this.publicKeyPem), {\n        md: sha256.create()\n      }); // RSA cryptonyms are multiformats encoded values, specifically they are:\n      // (multicodec RSA SPKI-based public key 0x5d + sha2-256 0x12 +\n      // 32 byte value 0x20)\n\n      buffer.putBytes(forge.util.hexToBytes('5d1220'));\n      buffer.putBytes(fingerprintBuffer.bytes()); // prefix with `z` to indicate multi-base base58btc encoding\n\n      return \"z\".concat(base58.encode(buffer));\n    }\n    /*\n     * Tests whether the fingerprint\n     * was generated from a given key pair.\n     * @example\n     * > rsaKeyPair.verifyFingerprint('zdsfdsfsdfdsfsd34234');\n     * {valid: true}\n     * @param {string} fingerprint - An RSA fingerprint for a key.\n     *\n     * @returns {boolean} True if the fingerprint is verified.\n     */\n\n  }, {\n    key: \"verifyFingerprint\",\n    value: function verifyFingerprint(fingerprint) {\n      // fingerprint should have `z` prefix indicating\n      // that it's multi-base encoded\n      if (!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n        return {\n          error: new Error('`fingerprint` must be a multibase encoded string.'),\n          valid: false\n        };\n      } // base58.decode returns Buffer(nodejs) or Uint8Array\n\n\n      var fingerprintBuffer = base58.decode(fingerprint.slice(1)); // keyFingerprintBuffer is a forge ByteStringBuffer\n\n      var keyFingerprintBuffer = getPublicKeyFingerprint(publicKeyFromPem(this.publicKeyPem), {\n        md: sha256.create()\n      }); // validate the first three multicodec bytes 0x5d1220\n\n      var valid = fingerprintBuffer.slice(0, 3).toString('hex') === '5d1220' && keyFingerprintBuffer.toHex() === fingerprintBuffer.slice(3).toString('hex');\n\n      if (!valid) {\n        return {\n          error: new Error('The fingerprint does not match the public key.'),\n          valid: false\n        };\n      }\n\n      return {\n        valid: valid\n      };\n    }\n    /* eslint-disable max-len */\n\n    /**\n     * Returns a signer object with an async sign function for use by\n     * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}\n     * to sign content in a signature.\n     * @example\n     * > const signer = rsaKeyPair.signer();\n     * > signer.sign({data});\n     *\n     * @returns {{sign: Function}} An RSA Signer Function for a single key.\n     * for a single Private Key.\n     */\n\n    /* eslint-enable */\n\n  }, {\n    key: \"signer\",\n    value: function signer() {\n      return rsaSignerFactory(this);\n    }\n    /* eslint-disable max-len */\n\n    /**\n     * Returns a verifier object with an async\n     * function verify for use with\n     * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n     * @example\n     * > const verifier = rsaKeyPair.verifier();\n     * > const valid = await verifier.verify({data, signature});\n     *\n     * @returns {{verify: Function}} An RSA Verifier Function for a single key.\n     */\n\n    /* eslint-enable */\n\n  }, {\n    key: \"verifier\",\n    value: function verifier() {\n      return rsaVerifierFactory(this);\n    }\n  }], [{\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var options,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  forge.pki.rsa.generateKeyPair({\n                    bits: DEFAULT_RSA_KEY_BITS,\n                    e: DEFAULT_RSA_EXPONENT,\n                    workers: -1\n                  }, function (err, keyPair) {\n                    if (err) {\n                      return reject(err);\n                    }\n\n                    resolve(new RSAKeyPair(_objectSpread({\n                      publicKeyPem: forge.pki.publicKeyToPem(keyPair.publicKey),\n                      privateKeyPem: forge.pki.privateKeyToPem(keyPair.privateKey)\n                    }, options)));\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function generate() {\n        return _generate.apply(this, arguments);\n      }\n\n      return generate;\n    }()\n    /**\n     * Creates a RSA Key Pair from an existing private key.\n     * @example\n     * > const options = {\n     *    privateKeyPem: 'testkeypem'\n     *  };\n     * > const key = await RSAKeyPair.from(options);\n     * @param {Object} options - Contains a private key.\n     * @param {Object} [options.privateKey] - A private key.\n     * @param {string} [options.privateKeyPem] - An RSA Private key.\n     *\n     * @returns {RSAKeyPair} An RSA Key Pair.\n     */\n\n  }, {\n    key: \"from\",\n    value: function () {\n      var _from = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(options) {\n        var privateKeyPem, keys;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                privateKeyPem = options.privateKeyPem || // legacy privateDidDoc format\n                options.privateKeyPem && options.privateKey.privateKeyPem;\n                keys = new RSAKeyPair(_objectSpread({\n                  publicKey: options.publicKeyPem,\n                  privateKeyPem: privateKeyPem,\n                  type: options.type || options.keyType\n                }, options));\n                return _context3.abrupt(\"return\", keys);\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function from(_x2) {\n        return _from.apply(this, arguments);\n      }\n\n      return from;\n    }()\n  }]);\n\n  return RSAKeyPair;\n}(LDKeyPair);\n/**\n * @ignore\n * Returns an object with an async sign function.\n * The sign function is bound to the KeyPair\n * and then returned by the KeyPair's signer method.\n * @example\n * > const factory = rsaSignerFactory(rsaKeyPair);\n * > const bytes = await factory.sign({data});\n * @param {RSAKeyPair} key - They key this factory will verify for.\n *\n * @returns {{sign: Function}} An RSA Verifier Function for a single key.\n */\n\n\nfunction rsaSignerFactory(key) {\n  if (!key.privateKeyPem) {\n    return {\n      sign: function sign() {\n        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n          return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  throw new Error('No private key to sign with.');\n\n                case 1:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4);\n        }))();\n      }\n    };\n  } // Note: Per rfc7518, the digest algorithm for PS256 is SHA-256,\n  // https://tools.ietf.org/html/rfc7518\n  // sign data using RSASSA-PSS where PSS uses a SHA-256 hash,\n  // a SHA-256 based masking function MGF1, and a 32 byte salt to match\n  // the hash size\n\n\n  if (env.nodejs) {\n    // node.js 8+\n    var crypto = require('crypto');\n\n    if ('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        sign: function sign(_ref) {\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n            var data, signer, buffer;\n            return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n              while (1) {\n                switch (_context5.prev = _context5.next) {\n                  case 0:\n                    data = _ref.data;\n                    signer = crypto.createSign('RSA-SHA256');\n                    signer.update(Buffer.from(data.buffer, data.byteOffset, data.length));\n                    buffer = signer.sign({\n                      key: key.privateKeyPem,\n                      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n                      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n                    });\n                    return _context5.abrupt(\"return\", new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length));\n\n                  case 5:\n                  case \"end\":\n                    return _context5.stop();\n                }\n              }\n            }, _callee5);\n          }))();\n        }\n      };\n    }\n  } // browser or other environment (including node 6.x)\n\n\n  var privateKey = forge.pki.privateKeyFromPem(key.privateKeyPem);\n  return {\n    sign: function sign(_ref2) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var data, pss, md, binaryString;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                data = _ref2.data;\n                pss = createPss();\n                md = sha256.create();\n                md.update(raw.encode(data), 'binary');\n                binaryString = privateKey.sign(md, pss);\n                return _context6.abrupt(\"return\", raw.decode(binaryString));\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }))();\n    }\n  };\n}\n/**\n * @ignore\n * Returns an object with an async verify function.\n * The verify function is bound to the KeyPair\n * and then returned by the KeyPair's verifier method.\n * @example\n * > const verifier = rsaVerifierFactory(rsaKeyPair);\n * > verifier.verify({data, signature});\n * false\n * @param {RSAKeyPair} key - An RSAKeyPair.\n *\n * @returns {Function} An RSA Verifier for the key pair passed in.\n */\n\n\nfunction rsaVerifierFactory(key) {\n  if (env.nodejs) {\n    // node.js 8+\n    var crypto = require('crypto');\n\n    if ('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        verify: function verify(_ref3) {\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n            var data, signature, verifier;\n            return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n              while (1) {\n                switch (_context7.prev = _context7.next) {\n                  case 0:\n                    data = _ref3.data, signature = _ref3.signature;\n                    verifier = crypto.createVerify('RSA-SHA256');\n                    verifier.update(Buffer.from(data.buffer, data.byteOffset, data.length));\n                    return _context7.abrupt(\"return\", verifier.verify({\n                      key: key.publicKeyPem,\n                      padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n                      saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n                    }, Buffer.from(signature.buffer, signature.byteOffset, signature.length)));\n\n                  case 4:\n                  case \"end\":\n                    return _context7.stop();\n                }\n              }\n            }, _callee7);\n          }))();\n        }\n      };\n    }\n  } // browser or other environment (including node 6.x)\n\n\n  var publicKey = publicKeyFromPem(key.publicKeyPem);\n  return {\n    verify: function verify(_ref4) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var data, signature, pss, md;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                data = _ref4.data, signature = _ref4.signature;\n                pss = createPss();\n                md = sha256.create();\n                md.update(raw.encode(data), 'binary');\n                _context8.prev = 4;\n                return _context8.abrupt(\"return\", publicKey.verify(md.digest().bytes(), raw.encode(signature), pss));\n\n              case 8:\n                _context8.prev = 8;\n                _context8.t0 = _context8[\"catch\"](4);\n                return _context8.abrupt(\"return\", false);\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[4, 8]]);\n      }))();\n    }\n  };\n}\n/**\n * @ignore\n * creates an RSA PSS used in signatures.\n * @example\n * > const pss = createPss();\n *\n * @returns {PSS} A PSS object.\n * @see [PSS]{@link ./index.md#PSS}\n */\n\n\nfunction createPss() {\n  var md = sha256.create();\n  return forge.pss.create({\n    md: md,\n    mgf: forge.mgf.mgf1.create(sha256.create()),\n    saltLength: md.digestLength\n  });\n}\n\nmodule.exports = RSAKeyPair;","map":{"version":3,"sources":["D:/My Works/Git/cowin-verify/node_modules/crypto-ld/lib/RSAKeyPair.js"],"names":["env","require","forge","sha256","md","pki","getPublicKeyFingerprint","publicKeyFromPem","util","binary","base58","raw","LDKeyPair","DEFAULT_RSA_KEY_BITS","DEFAULT_RSA_EXPONENT","RSAKeyPair","options","type","privateKeyPem","publicKeyPem","validateKeyParams","publicKey","keyBits","n","bitLength","Error","JSON","stringify","e","toString","privateKey","privateKeyFromPem","publicKeyNode","keyNode","passphrase","encryptRsaPrivateKey","algorithm","buffer","createBuffer","fingerprintBuffer","create","putBytes","hexToBytes","bytes","encode","fingerprint","error","valid","decode","slice","keyFingerprintBuffer","toHex","rsaSignerFactory","rsaVerifierFactory","Promise","resolve","reject","rsa","generateKeyPair","bits","workers","err","keyPair","publicKeyToPem","privateKeyToPem","keys","keyType","key","sign","nodejs","crypto","constants","data","signer","createSign","update","Buffer","from","byteOffset","length","padding","RSA_PKCS1_PSS_PADDING","saltLength","RSA_PSS_SALTLEN_DIGEST","Uint8Array","pss","createPss","binaryString","verify","signature","verifier","createVerify","digest","mgf","mgf1","digestLength","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst env = require('./env');\nconst forge = require('node-forge');\nconst {\n  md: {sha256},\n  pki: {getPublicKeyFingerprint, publicKeyFromPem},\n  util: {binary: {base58, raw}}\n} = forge;\nconst LDKeyPair = require('./LDKeyPair');\n\n/**\n * @constant\n * @type {number}\n * @default\n */\nconst DEFAULT_RSA_KEY_BITS = 2048;\n\n/**\n * @constant\n * @type {number}\n * @default\n */\nconst DEFAULT_RSA_EXPONENT = 0x10001;\n\nclass RSAKeyPair extends LDKeyPair {\n  /* eslint-disable max-len */\n  /**\n   * An implementation of\n   * [RSA encryption]{@link https://simple.wikipedia.org/wiki/RSA_algorithm}\n   * for\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * @example\n   * > const options = {\n   *    privateKeyPem: 'testPrivateKey',\n   *    publicKeyPem: 'testPublicKey'\n   *  };\n   * > const RSAKey = new RSAKeyPair(options);\n   * @param {KeyPairOptions} options - Keys must be in RSA format other\n   * options must follow [KeyPairOptions]{@link ./index.md#KeyPairOptions}.\n   * @param {string} options.publicKeyPem - Public Key for Signatures.\n   * @param {string} options.privateKeyPem - Your Confidential key for signing.\n   */\n  /* eslint-enable */\n  constructor(options = {}) {\n    super(options);\n    this.type = 'RsaVerificationKey2018';\n    this.privateKeyPem = options.privateKeyPem;\n    this.publicKeyPem = options.publicKeyPem;\n\n    this.validateKeyParams(); // validate keyBits and exponent\n  }\n  /**\n   * Returns the public key.\n   * @implements {LDKeyPair#publicKey}\n   * @readonly\n   *\n   * @returns {string} The public key.\n   * @see [publicKey]{@link ./LDKeyPair.md#publicKey}\n   */\n  get publicKey() {\n    return this.publicKeyPem;\n  }\n  /**\n   * Returns the private key.\n   * @implements {LDKeyPair#privateKey}\n   * @readonly\n   *\n   * @returns {string} The private key.\n   * @see [privateKey]{@link ./LDKeyPair.md#privateKey}\n   */\n  get privateKey() {\n    return this.privateKeyPem;\n  }\n\n  /**\n   * Generates an RSA KeyPair using the RSA Defaults.\n   * @example\n   * > const keyPair = await RSAKeyPair.generate();\n   * > keyPair\n   * RSAKeyPair { ...\n   * @param {KeyPairOptions} [options={}] - See LDKeyPair\n   * docstring for full list.\n   *\n   * @returns {Promise<RSAKeyPair>} A Default encrypted RSA KeyPair.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  static async generate(options = {}) {\n    // forge will use a native implementation in nodejs >= 10.12.0\n    // and a purejs implementation in browser and nodejs < 10.12.0\n    return new Promise((resolve, reject) => {\n      forge.pki.rsa.generateKeyPair({\n        bits: DEFAULT_RSA_KEY_BITS,\n        e: DEFAULT_RSA_EXPONENT,\n        workers: -1\n      }, (err, keyPair) => {\n        if(err) {\n          return reject(err);\n        }\n        resolve(new RSAKeyPair({\n          publicKeyPem: forge.pki.publicKeyToPem(keyPair.publicKey),\n          privateKeyPem: forge.pki.privateKeyToPem(keyPair.privateKey),\n          ...options\n        }));\n      });\n    });\n  }\n  /**\n   * Creates a RSA Key Pair from an existing private key.\n   * @example\n   * > const options = {\n   *    privateKeyPem: 'testkeypem'\n   *  };\n   * > const key = await RSAKeyPair.from(options);\n   * @param {Object} options - Contains a private key.\n   * @param {Object} [options.privateKey] - A private key.\n   * @param {string} [options.privateKeyPem] - An RSA Private key.\n   *\n   * @returns {RSAKeyPair} An RSA Key Pair.\n   */\n  static async from(options) {\n    const privateKeyPem = options.privateKeyPem ||\n      // legacy privateDidDoc format\n      (options.privateKeyPem && options.privateKey.privateKeyPem);\n\n    const keys = new RSAKeyPair({\n      publicKey: options.publicKeyPem,\n      privateKeyPem,\n      type: options.type || options.keyType, // todo: deprecate keyType usage\n      ...options\n    });\n\n    return keys;\n  }\n  /**\n   * Validates this key.\n   * @example\n   * > rsaKeyPair.validateKeyParams();\n   * undefined\n   *\n   * @returns {undefined} If it does not throw then the key is valid.\n   * @throws Invalid RSA keyBit length\n   * @throws Invalid RSA exponent\n   */\n  validateKeyParams() {\n    if(this.publicKeyPem) {\n      const publicKey = forge.pki.publicKeyFromPem(this.publicKeyPem);\n      const keyBits = publicKey.n.bitLength();\n      if(keyBits !== DEFAULT_RSA_KEY_BITS) {\n        throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)}` +\n          ` required value is ${DEFAULT_RSA_KEY_BITS}`);\n      }\n      if(publicKey.e.toString(10) !== '65537') {\n        throw new Error(\n          `Invalid RSA exponent ${JSON.stringify(publicKey.e.toString(10))}` +\n          ' required value is 65537}');\n      }\n    }\n\n    if(this.privateKeyPem) {\n      const privateKey = forge.pki.privateKeyFromPem(this.privateKeyPem);\n      const keyBits = privateKey.n.bitLength();\n      if(keyBits !== DEFAULT_RSA_KEY_BITS) {\n        throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)}` +\n          ` required value is ${DEFAULT_RSA_KEY_BITS}`);\n      }\n      if(privateKey.e.toString(10) !== '65537') {\n        throw new Error(\n          `Invalid RSA exponent ${JSON.stringify(privateKey.e.toString(10))}` +\n          ' required value is 65537}');\n      }\n    }\n  }\n\n  /**\n   * Adds this KeyPair's publicKeyPem to a public node.\n   * @example\n   * > rsaKeyPair.addEncodedPublicKey({id: 'testnode'});\n   * { publicKeyPem: 'testPublicKey' }\n   * @param {KeyPairOptions} publicKeyNode - A Node with out a publicKeyPem set.\n   *\n   * @returns {KeyPairOptions} A public node with a publicKeyPem set.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  addEncodedPublicKey(publicKeyNode) {\n    publicKeyNode.publicKeyPem = this.publicKeyPem;\n    return publicKeyNode;\n  }\n  /**\n   * Adds this KeyPair's privateKeyPem to a public node.\n   * @example\n   * > rsaKeyPair.addEncryptedPrivateKey({id: 'testnode'});\n   * { privateKeyPem: 'testPrivateKey' }\n   * @param {KeyPairOptions} keyNode - A Node with out a publicKeyPem set.\n   *\n   * @returns {KeyPairOptions} A public node with a privateKeyPem set.\n   * @see [KeyPairOptions]{@link ./index.md#KeyPairOptions}\n   */\n  async addEncryptedPrivateKey(keyNode) {\n    if(this.passphrase !== null) {\n      keyNode.privateKeyPem = forge.pki.encryptRsaPrivateKey(\n        forge.pki.privateKeyFromPem(this.privateKeyPem),\n        this.passphrase,\n        {algorithm: 'aes256'}\n      );\n    } else {\n      // no passphrase, do not encrypt private key\n      keyNode.privateKeyPem = this.privateKeyPem;\n    }\n    return keyNode;\n  }\n\n  /**\n   * Generates and returns a multiformats\n   * encoded RSA public key fingerprint (for use with cryptonyms, for example).\n   * @example\n   * > rsaKeyPair.fingerprint();\n   * 3423dfdsf3432sdfdsds\n   *\n   * @returns {string} An RSA fingerprint.\n   */\n  fingerprint() {\n    const buffer = forge.util.createBuffer();\n\n    // use SubjectPublicKeyInfo fingerprint\n    const fingerprintBuffer = forge.pki.getPublicKeyFingerprint(\n      forge.pki.publicKeyFromPem(this.publicKeyPem),\n      {md: sha256.create()});\n    // RSA cryptonyms are multiformats encoded values, specifically they are:\n    // (multicodec RSA SPKI-based public key 0x5d + sha2-256 0x12 +\n    // 32 byte value 0x20)\n    buffer.putBytes(forge.util.hexToBytes('5d1220'));\n    buffer.putBytes(fingerprintBuffer.bytes());\n\n    // prefix with `z` to indicate multi-base base58btc encoding\n    return `z${base58.encode(buffer)}`;\n  }\n\n  /*\n   * Tests whether the fingerprint\n   * was generated from a given key pair.\n   * @example\n   * > rsaKeyPair.verifyFingerprint('zdsfdsfsdfdsfsd34234');\n   * {valid: true}\n   * @param {string} fingerprint - An RSA fingerprint for a key.\n   *\n   * @returns {boolean} True if the fingerprint is verified.\n   */\n  verifyFingerprint(fingerprint) {\n    // fingerprint should have `z` prefix indicating\n    // that it's multi-base encoded\n    if(!(typeof fingerprint === 'string' && fingerprint[0] === 'z')) {\n      return {\n        error: new Error('`fingerprint` must be a multibase encoded string.'),\n        valid: false\n      };\n    }\n    // base58.decode returns Buffer(nodejs) or Uint8Array\n    const fingerprintBuffer = base58.decode(fingerprint.slice(1));\n    // keyFingerprintBuffer is a forge ByteStringBuffer\n    const keyFingerprintBuffer = getPublicKeyFingerprint(\n      publicKeyFromPem(this.publicKeyPem), {md: sha256.create()});\n\n    // validate the first three multicodec bytes 0x5d1220\n    const valid = fingerprintBuffer.slice(0, 3).toString('hex') === '5d1220' &&\n      keyFingerprintBuffer.toHex() ===\n      fingerprintBuffer.slice(3).toString('hex');\n    if(!valid) {\n      return {\n        error: new Error('The fingerprint does not match the public key.'),\n        valid: false\n      };\n    }\n\n    return {valid};\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a signer object with an async sign function for use by\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}\n   * to sign content in a signature.\n   * @example\n   * > const signer = rsaKeyPair.signer();\n   * > signer.sign({data});\n   *\n   * @returns {{sign: Function}} An RSA Signer Function for a single key.\n   * for a single Private Key.\n   */\n  /* eslint-enable */\n  signer() {\n    return rsaSignerFactory(this);\n  }\n\n  /* eslint-disable max-len */\n  /**\n   * Returns a verifier object with an async\n   * function verify for use with\n   * [jsonld-signatures]{@link https://github.com/digitalbazaar/jsonld-signatures}.\n   * @example\n   * > const verifier = rsaKeyPair.verifier();\n   * > const valid = await verifier.verify({data, signature});\n   *\n   * @returns {{verify: Function}} An RSA Verifier Function for a single key.\n   */\n  /* eslint-enable */\n  verifier() {\n    return rsaVerifierFactory(this);\n  }\n}\n\n/**\n * @ignore\n * Returns an object with an async sign function.\n * The sign function is bound to the KeyPair\n * and then returned by the KeyPair's signer method.\n * @example\n * > const factory = rsaSignerFactory(rsaKeyPair);\n * > const bytes = await factory.sign({data});\n * @param {RSAKeyPair} key - They key this factory will verify for.\n *\n * @returns {{sign: Function}} An RSA Verifier Function for a single key.\n */\nfunction rsaSignerFactory(key) {\n  if(!key.privateKeyPem) {\n    return {\n      async sign() {\n        throw new Error('No private key to sign with.');\n      }\n    };\n  }\n\n  // Note: Per rfc7518, the digest algorithm for PS256 is SHA-256,\n  // https://tools.ietf.org/html/rfc7518\n\n  // sign data using RSASSA-PSS where PSS uses a SHA-256 hash,\n  // a SHA-256 based masking function MGF1, and a 32 byte salt to match\n  // the hash size\n  if(env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n    if('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async sign({data}) {\n          const signer = crypto.createSign('RSA-SHA256');\n          signer.update(Buffer.from(data.buffer, data.byteOffset, data.length));\n          const buffer = signer.sign({\n            key: key.privateKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          });\n          return new Uint8Array(\n            buffer.buffer, buffer.byteOffset, buffer.length);\n        }\n      };\n    }\n  }\n\n  // browser or other environment (including node 6.x)\n  const privateKey = forge.pki.privateKeyFromPem(key.privateKeyPem);\n  return {\n    async sign({data}) {\n      const pss = createPss();\n      const md = sha256.create();\n      md.update(raw.encode(data), 'binary');\n      const binaryString = privateKey.sign(md, pss);\n      return raw.decode(binaryString);\n    }\n  };\n}\n\n/**\n * @ignore\n * Returns an object with an async verify function.\n * The verify function is bound to the KeyPair\n * and then returned by the KeyPair's verifier method.\n * @example\n * > const verifier = rsaVerifierFactory(rsaKeyPair);\n * > verifier.verify({data, signature});\n * false\n * @param {RSAKeyPair} key - An RSAKeyPair.\n *\n * @returns {Function} An RSA Verifier for the key pair passed in.\n */\nfunction rsaVerifierFactory(key) {\n  if(env.nodejs) {\n    // node.js 8+\n    const crypto = require('crypto');\n    if('RSA_PKCS1_PSS_PADDING' in crypto.constants) {\n      return {\n        async verify({data, signature}) {\n          const verifier = crypto.createVerify('RSA-SHA256');\n          verifier.update(\n            Buffer.from(data.buffer, data.byteOffset, data.length));\n          return verifier.verify({\n            key: key.publicKeyPem,\n            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,\n            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST\n          }, Buffer.from(\n            signature.buffer, signature.byteOffset, signature.length));\n        }\n      };\n    }\n  }\n\n  // browser or other environment (including node 6.x)\n  const publicKey = publicKeyFromPem(key.publicKeyPem);\n  return {\n    async verify({data, signature}) {\n      const pss = createPss();\n      const md = sha256.create();\n      md.update(raw.encode(data), 'binary');\n      try {\n        return publicKey.verify(\n          md.digest().bytes(),\n          raw.encode(signature),\n          pss);\n      } catch(e) {\n        // simply return false, do return information about malformed signature\n        return false;\n      }\n    }\n  };\n}\n\n/**\n * @ignore\n * creates an RSA PSS used in signatures.\n * @example\n * > const pss = createPss();\n *\n * @returns {PSS} A PSS object.\n * @see [PSS]{@link ./index.md#PSS}\n */\nfunction createPss() {\n  const md = sha256.create();\n  return forge.pss.create({\n    md,\n    mgf: forge.mgf.mgf1.create(sha256.create()),\n    saltLength: md.digestLength\n  });\n}\n\nmodule.exports = RSAKeyPair;\n"]},"metadata":{},"sourceType":"script"}